{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\n\nconst primitives_1 = require(\"./primitives\");\n\nconst WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\r\n * Algorithm for detecting transaction completion.\r\n * Based on some heuristics (a bit imprecise therefore, at this moment).\r\n */\n\nclass TransactionCompletionStrategyOnProxy {\n  isCompleted(transaction) {\n    if (transaction.status.isPending()) {\n      // Certainly not completed.\n      return false;\n    } // Handle gateway mechanics:\n\n\n    for (const completionEvent of WellKnownCompletionEvents) {\n      if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n        // Certainly completed.\n        console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n        return true;\n      }\n    }\n\n    if (this.isCertainlyMoveBalance(transaction.data)) {\n      return transaction.status.isExecuted();\n    }\n\n    let hyperblockNonce = transaction.hyperblockNonce; // Imprecise condition, uncertain completion (usually sufficient, though).\n    // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n\n    if (hyperblockNonce > 0) {\n      console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n      return true;\n    }\n\n    return false;\n  }\n\n  isCertainlyMoveBalance(transactionData) {\n    let parts = transactionData.toString().split(\"@\");\n    let prefix = parts[0];\n    let otherParts = parts.slice(1);\n    let emptyPrefix = !prefix;\n    let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));\n    return emptyPrefix || somePartsAreNotValidArguments;\n  }\n\n  looksLikeValidArgument(arg) {\n    return primitives_1.isPaddedHex(arg);\n  }\n\n}\n\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\n\nclass TransactionCompletionStrategyOnAPI {\n  isCompleted(transaction) {\n    return !transaction.status.isPending();\n  }\n\n}\n\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;","map":{"version":3,"sources":["../src/transactionCompletionStrategy.ts"],"names":[],"mappings":";;;;;;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AASA,MAAM,yBAAyB,GAAG,CAAC,kBAAD,EAAqB,UAArB,EAAiC,aAAjC,CAAlC;AAEA;;;AAGG;;AACH,MAAa,oCAAb,CAAiD;EAC7C,WAAW,CAAC,WAAD,EAAmC;IAC1C,IAAI,WAAW,CAAC,MAAZ,CAAmB,SAAnB,EAAJ,EAAoC;MAChC;MACA,OAAO,KAAP;IACH,CAJyC,CAM1C;;;IACA,KAAK,MAAM,eAAX,IAA8B,yBAA9B,EAAyD;MACrD,IAAI,WAAW,CAAC,IAAZ,CAAiB,oBAAjB,CAAsC,eAAtC,CAAJ,EAA4D;QACxD;QACA,OAAO,CAAC,KAAR,CAAc,2DAAd,EAA2E,eAA3E;QACA,OAAO,IAAP;MACH;IACJ;;IAED,IAAI,KAAK,sBAAL,CAA4B,WAAW,CAAC,IAAxC,CAAJ,EAAmD;MAC/C,OAAO,WAAW,CAAC,MAAZ,CAAmB,UAAnB,EAAP;IACH;;IAED,IAAI,eAAe,GAAG,WAAW,CAAC,eAAlC,CAnB0C,CAqB1C;IACA;;IACA,IAAI,eAAe,GAAG,CAAtB,EAAyB;MACrB,OAAO,CAAC,KAAR,CAAc,sEAAd,EAAsF,eAAtF;MACA,OAAO,IAAP;IACH;;IAED,OAAO,KAAP;EACH;;EAEO,sBAAsB,CAAC,eAAD,EAAwB;IAClD,IAAI,KAAK,GAAG,eAAe,CAAC,QAAhB,GAA2B,KAA3B,CAAiC,GAAjC,CAAZ;IACA,IAAI,MAAM,GAAG,KAAK,CAAC,CAAD,CAAlB;IACA,IAAI,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAjB;IACA,IAAI,WAAW,GAAG,CAAC,MAAnB;IACA,IAAI,6BAA6B,GAAG,CAAC,UAAU,CAAC,KAAX,CAAiB,IAAI,IAAI,KAAK,sBAAL,CAA4B,IAA5B,CAAzB,CAArC;IAEA,OAAO,WAAW,IAAI,6BAAtB;EACH;;EAEO,sBAAsB,CAAC,GAAD,EAAY;IACtC,OAAO,YAAA,CAAA,WAAA,CAAY,GAAZ,CAAP;EACH;;AA5C4C;;AAAjD,OAAA,CAAA,oCAAA,GAAA,oCAAA;;AA+CA,MAAa,kCAAb,CAA+C;EAC3C,WAAW,CAAC,WAAD,EAAmC;IAC1C,OAAO,CAAC,WAAW,CAAC,MAAZ,CAAmB,SAAnB,EAAR;EACH;;AAH0C;;AAA/C,OAAA,CAAA,kCAAA,GAAA,kCAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\r\nconst primitives_1 = require(\"./primitives\");\r\nconst WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\r\n/**\r\n * Algorithm for detecting transaction completion.\r\n * Based on some heuristics (a bit imprecise therefore, at this moment).\r\n */\r\nclass TransactionCompletionStrategyOnProxy {\r\n    isCompleted(transaction) {\r\n        if (transaction.status.isPending()) {\r\n            // Certainly not completed.\r\n            return false;\r\n        }\r\n        // Handle gateway mechanics:\r\n        for (const completionEvent of WellKnownCompletionEvents) {\r\n            if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\r\n                // Certainly completed.\r\n                console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\r\n                return true;\r\n            }\r\n        }\r\n        if (this.isCertainlyMoveBalance(transaction.data)) {\r\n            return transaction.status.isExecuted();\r\n        }\r\n        let hyperblockNonce = transaction.hyperblockNonce;\r\n        // Imprecise condition, uncertain completion (usually sufficient, though).\r\n        // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\r\n        if (hyperblockNonce > 0) {\r\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCertainlyMoveBalance(transactionData) {\r\n        let parts = transactionData.toString().split(\"@\");\r\n        let prefix = parts[0];\r\n        let otherParts = parts.slice(1);\r\n        let emptyPrefix = !prefix;\r\n        let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));\r\n        return emptyPrefix || somePartsAreNotValidArguments;\r\n    }\r\n    looksLikeValidArgument(arg) {\r\n        return primitives_1.isPaddedHex(arg);\r\n    }\r\n}\r\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\r\nclass TransactionCompletionStrategyOnAPI {\r\n    isCompleted(transaction) {\r\n        return !transaction.status.isPending();\r\n    }\r\n}\r\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;\r\n//# sourceMappingURL=transactionCompletionStrategy.js.map"]},"metadata":{},"sourceType":"script"}