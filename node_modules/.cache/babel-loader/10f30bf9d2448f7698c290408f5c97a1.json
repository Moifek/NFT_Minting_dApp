{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst types_1 = require(\"./types\");\n\nvar jsonHandler = require(\"json-duplicate-key-handle\");\n\nclass TypeExpressionParser {\n  parse(expression) {\n    let root = this.doParse(expression);\n    let rootKeys = Object.keys(root);\n\n    if (rootKeys.length != 1) {\n      throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\n    }\n\n    let name = rootKeys[0];\n    let type = this.nodeToType(name, root[name]);\n    return type;\n  }\n\n  doParse(expression) {\n    let jsoned = this.getJsonedString(expression);\n\n    try {\n      return jsonHandler.parse(jsoned);\n    } catch (error) {\n      throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\n    }\n  }\n  /**\r\n   * Converts a raw type expression to a JSON, parsing-friendly format.\r\n   * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\r\n   *\r\n   * @param expression a string such as:\r\n   *\r\n   * ```\r\n   *  - Option<List<Address>>\r\n   *  - VarArgs<MultiArg2<bytes, Address>>\r\n   *  - MultiResultVec<MultiResult2<Address, u64>\r\n   * ```\r\n   */\n\n\n  getJsonedString(expression) {\n    let jsoned = \"\";\n\n    for (var i = 0; i < expression.length; i++) {\n      let char = expression.charAt(i);\n      let previousChar = expression.charAt(i - 1);\n      let nextChar = expression.charAt(i + 1);\n\n      if (char == \"<\") {\n        jsoned += \": {\";\n      } else if (char == \">\") {\n        if (previousChar != \">\") {\n          jsoned += \": {} }\";\n        } else {\n          jsoned += \"}\";\n        }\n      } else if (char == \",\") {\n        if (nextChar == \">\") {// Skip superfluous comma\n        } else {\n          jsoned += \": {},\";\n        }\n      } else {\n        jsoned += char;\n      }\n    } // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n\n\n    let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n    let tokens = jsoned // Hack for Safari compatibility, where we can't use negative lookbehind\n    .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(token => token);\n    jsoned = tokens.map(token => symbolsRegex.test(token) ? token : `\"${token}\"`).map(token => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\")).join(\"\");\n\n    if (tokens.length == 1) {\n      // Workaround for simple, non-generic types.\n      return `{${jsoned}: {}}`;\n    }\n\n    return `{${jsoned}}`;\n  }\n\n  nodeToType(name, node) {\n    if (name.charAt(name.length - 1) === \"1\") {\n      name = name.slice(0, -1);\n    }\n\n    let typeParameters = Object.keys(node).map(key => this.nodeToType(key, node[key]));\n    return new types_1.Type(name, typeParameters);\n  }\n\n}\n\nexports.TypeExpressionParser = TypeExpressionParser;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeExpressionParser = void 0;\r\nconst errors = __importStar(require(\"../../errors\"));\r\nconst types_1 = require(\"./types\");\r\nvar jsonHandler = require(\"json-duplicate-key-handle\");\r\nclass TypeExpressionParser {\r\n    parse(expression) {\r\n        let root = this.doParse(expression);\r\n        let rootKeys = Object.keys(root);\r\n        if (rootKeys.length != 1) {\r\n            throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\r\n        }\r\n        let name = rootKeys[0];\r\n        let type = this.nodeToType(name, root[name]);\r\n        return type;\r\n    }\r\n    doParse(expression) {\r\n        let jsoned = this.getJsonedString(expression);\r\n        try {\r\n            return jsonHandler.parse(jsoned);\r\n        }\r\n        catch (error) {\r\n            throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a raw type expression to a JSON, parsing-friendly format.\r\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\r\n     *\r\n     * @param expression a string such as:\r\n     *\r\n     * ```\r\n     *  - Option<List<Address>>\r\n     *  - VarArgs<MultiArg2<bytes, Address>>\r\n     *  - MultiResultVec<MultiResult2<Address, u64>\r\n     * ```\r\n     */\r\n    getJsonedString(expression) {\r\n        let jsoned = \"\";\r\n        for (var i = 0; i < expression.length; i++) {\r\n            let char = expression.charAt(i);\r\n            let previousChar = expression.charAt(i - 1);\r\n            let nextChar = expression.charAt(i + 1);\r\n            if (char == \"<\") {\r\n                jsoned += \": {\";\r\n            }\r\n            else if (char == \">\") {\r\n                if (previousChar != \">\") {\r\n                    jsoned += \": {} }\";\r\n                }\r\n                else {\r\n                    jsoned += \"}\";\r\n                }\r\n            }\r\n            else if (char == \",\") {\r\n                if (nextChar == \">\") {\r\n                    // Skip superfluous comma\r\n                }\r\n                else {\r\n                    jsoned += \": {},\";\r\n                }\r\n            }\r\n            else {\r\n                jsoned += char;\r\n            }\r\n        }\r\n        // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\r\n        let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\r\n        let tokens = jsoned\r\n            // Hack for Safari compatibility, where we can't use negative lookbehind\r\n            .replace(/utf\\-8\\sstring/ig, \"utf-8-string\")\r\n            .split(symbolsRegex)\r\n            .filter((token) => token);\r\n        jsoned = tokens.map((token) => (symbolsRegex.test(token) ? token : `\"${token}\"`))\r\n            .map((token) => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\"))\r\n            .join(\"\");\r\n        if (tokens.length == 1) {\r\n            // Workaround for simple, non-generic types.\r\n            return `{${jsoned}: {}}`;\r\n        }\r\n        return `{${jsoned}}`;\r\n    }\r\n    nodeToType(name, node) {\r\n        if (name.charAt(name.length - 1) === \"1\") {\r\n            name = name.slice(0, -1);\r\n        }\r\n        let typeParameters = Object.keys(node).map((key) => this.nodeToType(key, node[key]));\r\n        return new types_1.Type(name, typeParameters);\r\n    }\r\n}\r\nexports.TypeExpressionParser = TypeExpressionParser;\r\n//# sourceMappingURL=typeExpressionParser.js.map"]},"metadata":{},"sourceType":"script"}