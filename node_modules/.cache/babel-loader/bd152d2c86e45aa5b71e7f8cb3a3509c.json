{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nconst codec_1 = require(\"./codec\");\n\nconst composite_1 = require(\"./typesystem/composite\");\n\nconst variadic_1 = require(\"./typesystem/variadic\");\n\nconst algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\r\n * For the moment, this is the only codec used.\r\n */\n\nconst Codec = new codec_1.BinaryCodec();\n\nclass ArgSerializer {\n  /**\r\n   * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\r\n   */\n  stringToValues(joinedString, parameters) {\n    let buffers = this.stringToBuffers(joinedString);\n    let values = this.buffersToValues(buffers, parameters);\n    return values;\n  }\n  /**\r\n   * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\r\n   */\n\n\n  stringToBuffers(joinedString) {\n    // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n    return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n  }\n  /**\r\n   * Decodes a set of buffers into a set of typed values, given parameter definitions.\r\n   */\n\n\n  buffersToValues(buffers, parameters) {\n    // TODO: Refactor, split (function is quite complex).\n    buffers = buffers || [];\n    let values = [];\n    let bufferIndex = 0;\n    let numBuffers = buffers.length;\n\n    for (let i = 0; i < parameters.length; i++) {\n      let parameter = parameters[i];\n      let type = parameter.type;\n      let value = readValue(type);\n      values.push(value);\n    } // This is a recursive function.\n\n\n    function readValue(type) {\n      // TODO: Use matchers.\n      if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n        let typedValue = readValue(type.getFirstTypeParameter());\n        return new algebraic_1.OptionalValue(type, typedValue);\n      } else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n        let typedValues = [];\n\n        while (!hasReachedTheEnd()) {\n          typedValues.push(readValue(type.getFirstTypeParameter()));\n        }\n\n        return new variadic_1.VariadicValue(type, typedValues);\n      } else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n        let typedValues = [];\n\n        for (const typeParameter of type.getTypeParameters()) {\n          typedValues.push(readValue(typeParameter));\n        }\n\n        return new composite_1.CompositeValue(type, typedValues);\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let typedValue = decodeNextBuffer(type);\n        return typedValue;\n      }\n    }\n\n    function decodeNextBuffer(type) {\n      if (hasReachedTheEnd()) {\n        return null;\n      }\n\n      let buffer = buffers[bufferIndex++];\n      let decodedValue = Codec.decodeTopLevel(buffer, type);\n      return decodedValue;\n    }\n\n    function hasReachedTheEnd() {\n      return bufferIndex >= numBuffers;\n    }\n\n    return values;\n  }\n  /**\r\n   * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\r\n   */\n\n\n  valuesToString(values) {\n    let strings = this.valuesToStrings(values);\n    let argumentsString = strings.join(exports.ArgumentsSeparator);\n    let count = strings.length;\n    return {\n      argumentsString,\n      count\n    };\n  }\n  /**\r\n   * Serializes a set of typed values into a set of strings.\r\n   */\n\n\n  valuesToStrings(values) {\n    let buffers = this.valuesToBuffers(values);\n    let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n    return strings;\n  }\n  /**\r\n   * Serializes a set of typed values into a set of strings buffers.\r\n   * Variadic types and composite types might result into none, one or more buffers.\r\n   */\n\n\n  valuesToBuffers(values) {\n    // TODO: Refactor, split (function is quite complex).\n    let buffers = [];\n\n    for (const value of values) {\n      handleValue(value);\n    } // This is a recursive function. It appends to the \"buffers\" variable.\n\n\n    function handleValue(value) {\n      // TODO: Use matchers.\n      if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n        let valueAsOptional = value;\n\n        if (valueAsOptional.isSet()) {\n          handleValue(valueAsOptional.getTypedValue());\n        }\n      } else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n        let valueAsVariadic = value;\n\n        for (const item of valueAsVariadic.getItems()) {\n          handleValue(item);\n        }\n      } else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n        let valueAsComposite = value;\n\n        for (const item of valueAsComposite.getItems()) {\n          handleValue(item);\n        }\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let buffer = Codec.encodeTopLevel(value);\n        buffers.push(buffer);\n      }\n    }\n\n    return buffers;\n  }\n\n}\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"sources":["../../src/smartcontracts/argSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\r\nconst codec_1 = require(\"./codec\");\r\nconst composite_1 = require(\"./typesystem/composite\");\r\nconst variadic_1 = require(\"./typesystem/variadic\");\r\nconst algebraic_1 = require(\"./typesystem/algebraic\");\r\nexports.ArgumentsSeparator = \"@\";\r\n/**\r\n * For the moment, this is the only codec used.\r\n */\r\nconst Codec = new codec_1.BinaryCodec();\r\nclass ArgSerializer {\r\n    /**\r\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\r\n     */\r\n    stringToValues(joinedString, parameters) {\r\n        let buffers = this.stringToBuffers(joinedString);\r\n        let values = this.buffersToValues(buffers, parameters);\r\n        return values;\r\n    }\r\n    /**\r\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\r\n     */\r\n    stringToBuffers(joinedString) {\r\n        // We also keep the zero-length buffers (they could encode missing options, Option<T>).\r\n        return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\r\n    }\r\n    /**\r\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\r\n     */\r\n    buffersToValues(buffers, parameters) {\r\n        // TODO: Refactor, split (function is quite complex).\r\n        buffers = buffers || [];\r\n        let values = [];\r\n        let bufferIndex = 0;\r\n        let numBuffers = buffers.length;\r\n        for (let i = 0; i < parameters.length; i++) {\r\n            let parameter = parameters[i];\r\n            let type = parameter.type;\r\n            let value = readValue(type);\r\n            values.push(value);\r\n        }\r\n        // This is a recursive function.\r\n        function readValue(type) {\r\n            // TODO: Use matchers.\r\n            if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\r\n                let typedValue = readValue(type.getFirstTypeParameter());\r\n                return new algebraic_1.OptionalValue(type, typedValue);\r\n            }\r\n            else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\r\n                let typedValues = [];\r\n                while (!hasReachedTheEnd()) {\r\n                    typedValues.push(readValue(type.getFirstTypeParameter()));\r\n                }\r\n                return new variadic_1.VariadicValue(type, typedValues);\r\n            }\r\n            else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\r\n                let typedValues = [];\r\n                for (const typeParameter of type.getTypeParameters()) {\r\n                    typedValues.push(readValue(typeParameter));\r\n                }\r\n                return new composite_1.CompositeValue(type, typedValues);\r\n            }\r\n            else {\r\n                // Non-composite (singular), non-variadic (fixed) type.\r\n                // The only branching without a recursive call.\r\n                let typedValue = decodeNextBuffer(type);\r\n                return typedValue;\r\n            }\r\n        }\r\n        function decodeNextBuffer(type) {\r\n            if (hasReachedTheEnd()) {\r\n                return null;\r\n            }\r\n            let buffer = buffers[bufferIndex++];\r\n            let decodedValue = Codec.decodeTopLevel(buffer, type);\r\n            return decodedValue;\r\n        }\r\n        function hasReachedTheEnd() {\r\n            return bufferIndex >= numBuffers;\r\n        }\r\n        return values;\r\n    }\r\n    /**\r\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\r\n     */\r\n    valuesToString(values) {\r\n        let strings = this.valuesToStrings(values);\r\n        let argumentsString = strings.join(exports.ArgumentsSeparator);\r\n        let count = strings.length;\r\n        return { argumentsString, count };\r\n    }\r\n    /**\r\n     * Serializes a set of typed values into a set of strings.\r\n     */\r\n    valuesToStrings(values) {\r\n        let buffers = this.valuesToBuffers(values);\r\n        let strings = buffers.map(buffer => buffer.toString(\"hex\"));\r\n        return strings;\r\n    }\r\n    /**\r\n     * Serializes a set of typed values into a set of strings buffers.\r\n     * Variadic types and composite types might result into none, one or more buffers.\r\n     */\r\n    valuesToBuffers(values) {\r\n        // TODO: Refactor, split (function is quite complex).\r\n        let buffers = [];\r\n        for (const value of values) {\r\n            handleValue(value);\r\n        }\r\n        // This is a recursive function. It appends to the \"buffers\" variable.\r\n        function handleValue(value) {\r\n            // TODO: Use matchers.\r\n            if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\r\n                let valueAsOptional = value;\r\n                if (valueAsOptional.isSet()) {\r\n                    handleValue(valueAsOptional.getTypedValue());\r\n                }\r\n            }\r\n            else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\r\n                let valueAsVariadic = value;\r\n                for (const item of valueAsVariadic.getItems()) {\r\n                    handleValue(item);\r\n                }\r\n            }\r\n            else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\r\n                let valueAsComposite = value;\r\n                for (const item of valueAsComposite.getItems()) {\r\n                    handleValue(item);\r\n                }\r\n            }\r\n            else {\r\n                // Non-composite (singular), non-variadic (fixed) type.\r\n                // The only branching without a recursive call.\r\n                let buffer = Codec.encodeTopLevel(value);\r\n                buffers.push(buffer);\r\n            }\r\n        }\r\n        return buffers;\r\n    }\r\n}\r\nexports.ArgSerializer = ArgSerializer;\r\n//# sourceMappingURL=argSerializer.js.map"]},"metadata":{},"sourceType":"script"}