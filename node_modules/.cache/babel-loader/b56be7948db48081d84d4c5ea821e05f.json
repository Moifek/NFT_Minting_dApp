{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst utils_codec_1 = require(\"../../utils.codec\");\n/**\r\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\r\n * @param buffer the buffer to test\r\n * @param byteIndex the index of the byte to test\r\n */\n\n\nfunction isMsbOne(buffer) {\n  let byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let byte = buffer[byteIndex];\n  let bit = byte >> 7;\n  let isSet = bit == 1;\n  return isSet;\n}\n\nexports.isMsbOne = isMsbOne;\n/**\r\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\r\n * @param buffer the buffer to test\r\n * @param byteIndex the index of the byte to test\r\n */\n\nfunction isMsbZero(buffer) {\n  let byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return !isMsbOne(buffer, byteIndex);\n}\n\nexports.isMsbZero = isMsbZero;\n\nfunction cloneBuffer(buffer) {\n  let clone = Buffer.alloc(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\n\nexports.cloneBuffer = cloneBuffer;\n\nfunction bufferToBigInt(buffer) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\n  let hex = buffer.toString(\"hex\");\n  return new bignumber_js_1.default(`0x${hex}`, 16);\n}\n\nexports.bufferToBigInt = bufferToBigInt;\n\nfunction bigIntToBuffer(value) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\n  let hex = getHexMagnitudeOfBigInt(value);\n  return Buffer.from(hex, \"hex\");\n}\n\nexports.bigIntToBuffer = bigIntToBuffer;\n\nfunction getHexMagnitudeOfBigInt(value) {\n  if (!value) {\n    return \"\";\n  }\n\n  if (value.isNegative()) {\n    value = value.multipliedBy(new bignumber_js_1.default(-1));\n  }\n\n  return utils_codec_1.numberToPaddedHex(value);\n}\n\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\n\nfunction flipBufferBitsInPlace(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] = ~buffer[i];\n  }\n}\n\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\n\nfunction prependByteToBuffer(buffer, byte) {\n  return Buffer.concat([Buffer.from([byte]), buffer]);\n}\n\nexports.prependByteToBuffer = prependByteToBuffer;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA;;;;AAIG;;;AACH,SAAgB,QAAhB,CAAyB,MAAzB,EAA8D;EAAA,IAArB,SAAqB,uEAAD,CAAC;EAC1D,IAAI,IAAI,GAAG,MAAM,CAAC,SAAD,CAAjB;EACA,IAAI,GAAG,GAAG,IAAI,IAAI,CAAlB;EACA,IAAI,KAAK,GAAG,GAAG,IAAI,CAAnB;EACA,OAAO,KAAP;AACH;;AALD,OAAA,CAAA,QAAA,GAAA,QAAA;AAOA;;;;AAIG;;AACH,SAAgB,SAAhB,CAA0B,MAA1B,EAA+D;EAAA,IAArB,SAAqB,uEAAD,CAAC;EAC3D,OAAO,CAAC,QAAQ,CAAC,MAAD,EAAS,SAAT,CAAhB;AACH;;AAFD,OAAA,CAAA,SAAA,GAAA,SAAA;;AAIA,SAAgB,WAAhB,CAA4B,MAA5B,EAA0C;EACtC,IAAI,KAAK,GAAG,MAAM,CAAC,KAAP,CAAa,MAAM,CAAC,MAApB,CAAZ;EACA,MAAM,CAAC,IAAP,CAAY,KAAZ;EACA,OAAO,KAAP;AACH;;AAJD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAMA,SAAgB,cAAhB,CAA+B,MAA/B,EAA6C;EACzC;EACA,IAAI,GAAG,GAAG,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAAV;EACA,OAAO,IAAI,cAAA,CAAA,OAAJ,CAAc,KAAK,GAAG,EAAtB,EAA0B,EAA1B,CAAP;AACH;;AAJD,OAAA,CAAA,cAAA,GAAA,cAAA;;AAMA,SAAgB,cAAhB,CAA+B,KAA/B,EAA+C;EAC3C;EACA,IAAI,GAAG,GAAG,uBAAuB,CAAC,KAAD,CAAjC;EACA,OAAO,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,KAAjB,CAAP;AACH;;AAJD,OAAA,CAAA,cAAA,GAAA,cAAA;;AAMA,SAAgB,uBAAhB,CAAwC,KAAxC,EAAwD;EACpD,IAAI,CAAC,KAAL,EAAY;IACR,OAAO,EAAP;EACH;;EAED,IAAI,KAAK,CAAC,UAAN,EAAJ,EAAwB;IACpB,KAAK,GAAG,KAAK,CAAC,YAAN,CAAmB,IAAI,cAAA,CAAA,OAAJ,CAAc,CAAC,CAAf,CAAnB,CAAR;EACH;;EAED,OAAO,aAAA,CAAA,iBAAA,CAAkB,KAAlB,CAAP;AACH;;AAVD,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAYA,SAAgB,qBAAhB,CAAsC,MAAtC,EAAoD;EAChD,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;IACpC,MAAM,CAAC,CAAD,CAAN,GAAY,CAAC,MAAM,CAAC,CAAD,CAAnB;EACH;AACJ;;AAJD,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAMA,SAAgB,mBAAhB,CAAoC,MAApC,EAAoD,IAApD,EAAgE;EAC5D,OAAO,MAAM,CAAC,MAAP,CAAc,CAAC,MAAM,CAAC,IAAP,CAAY,CAAC,IAAD,CAAZ,CAAD,EAAsB,MAAtB,CAAd,CAAP;AACH;;AAFD,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\r\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\r\nconst utils_codec_1 = require(\"../../utils.codec\");\r\n/**\r\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\r\n * @param buffer the buffer to test\r\n * @param byteIndex the index of the byte to test\r\n */\r\nfunction isMsbOne(buffer, byteIndex = 0) {\r\n    let byte = buffer[byteIndex];\r\n    let bit = byte >> 7;\r\n    let isSet = bit == 1;\r\n    return isSet;\r\n}\r\nexports.isMsbOne = isMsbOne;\r\n/**\r\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\r\n * @param buffer the buffer to test\r\n * @param byteIndex the index of the byte to test\r\n */\r\nfunction isMsbZero(buffer, byteIndex = 0) {\r\n    return !isMsbOne(buffer, byteIndex);\r\n}\r\nexports.isMsbZero = isMsbZero;\r\nfunction cloneBuffer(buffer) {\r\n    let clone = Buffer.alloc(buffer.length);\r\n    buffer.copy(clone);\r\n    return clone;\r\n}\r\nexports.cloneBuffer = cloneBuffer;\r\nfunction bufferToBigInt(buffer) {\r\n    // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\r\n    let hex = buffer.toString(\"hex\");\r\n    return new bignumber_js_1.default(`0x${hex}`, 16);\r\n}\r\nexports.bufferToBigInt = bufferToBigInt;\r\nfunction bigIntToBuffer(value) {\r\n    // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\r\n    let hex = getHexMagnitudeOfBigInt(value);\r\n    return Buffer.from(hex, \"hex\");\r\n}\r\nexports.bigIntToBuffer = bigIntToBuffer;\r\nfunction getHexMagnitudeOfBigInt(value) {\r\n    if (!value) {\r\n        return \"\";\r\n    }\r\n    if (value.isNegative()) {\r\n        value = value.multipliedBy(new bignumber_js_1.default(-1));\r\n    }\r\n    return utils_codec_1.numberToPaddedHex(value);\r\n}\r\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\r\nfunction flipBufferBitsInPlace(buffer) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        buffer[i] = ~buffer[i];\r\n    }\r\n}\r\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\r\nfunction prependByteToBuffer(buffer, byte) {\r\n    return Buffer.concat([Buffer.from([byte]), buffer]);\r\n}\r\nexports.prependByteToBuffer = prependByteToBuffer;\r\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}