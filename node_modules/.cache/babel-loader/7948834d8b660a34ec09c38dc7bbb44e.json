{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractInterface = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nconst NamePlaceholder = \"?\";\n/**\r\n * An Interace represents a (sub)set of endpoints (with their signatures included) defined by a contract.\r\n */\n\nclass ContractInterface {\n  constructor(name, constructor_definition, endpoints) {\n    this.endpoints = [];\n    this.name = name;\n    this.constructorDefinition = constructor_definition;\n    this.endpoints = endpoints;\n  }\n\n  static fromJSON(json) {\n    json.name = json.name || NamePlaceholder;\n    json.endpoints = json.endpoints || [];\n    let constructorDefinition = constructorFromJSON(json);\n    let endpoints = json.endpoints.map(item => endpoint_1.EndpointDefinition.fromJSON(item));\n    return new ContractInterface(json.name, constructorDefinition, endpoints);\n  }\n\n  getConstructorDefinition() {\n    return this.constructorDefinition;\n  }\n\n  getEndpoint(name) {\n    let result = this.endpoints.find(e => e.name == name);\n    utils_1.guardValueIsSetWithMessage(`endpoint [${name}] not found`, result);\n    return result;\n  }\n\n}\n\nexports.ContractInterface = ContractInterface;\n\nfunction constructorFromJSON(json) {\n  if (json.constructor.inputs === undefined || json.constructor.outputs === undefined) {\n    return null;\n  } // the name will be missing, so we add it manually\n\n\n  let constructorWithName = Object.assign({\n    name: \"constructor\"\n  }, json.constructor);\n  return endpoint_1.EndpointDefinition.fromJSON(constructorWithName);\n}","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/contractInterface.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAM,eAAe,GAAG,GAAxB;AAEA;;AAEG;;AACH,MAAa,iBAAb,CAA8B;EAK1B,WAAA,CAAY,IAAZ,EAA0B,sBAA1B,EAA6E,SAA7E,EAA4G;IAFnG,KAAA,SAAA,GAAkC,EAAlC;IAGL,KAAK,IAAL,GAAY,IAAZ;IACA,KAAK,qBAAL,GAA6B,sBAA7B;IACA,KAAK,SAAL,GAAiB,SAAjB;EACH;;EAEc,OAAR,QAAQ,CAAC,IAAD,EAA2D;IACtE,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,IAAL,IAAa,eAAzB;IACA,IAAI,CAAC,SAAL,GAAiB,IAAI,CAAC,SAAL,IAAkB,EAAnC;IAEA,IAAI,qBAAqB,GAAG,mBAAmB,CAAC,IAAD,CAA/C;IACA,IAAI,SAAS,GAAG,IAAI,CAAC,SAAL,CAAe,GAAf,CAAmB,IAAI,IAAI,UAAA,CAAA,kBAAA,CAAmB,QAAnB,CAA4B,IAA5B,CAA3B,CAAhB;IACA,OAAO,IAAI,iBAAJ,CAAsB,IAAI,CAAC,IAA3B,EAAiC,qBAAjC,EAAwD,SAAxD,CAAP;EACH;;EAED,wBAAwB,GAAA;IACpB,OAAO,KAAK,qBAAZ;EACH;;EAED,WAAW,CAAC,IAAD,EAAa;IACpB,IAAI,MAAM,GAAG,KAAK,SAAL,CAAe,IAAf,CAAoB,CAAC,IAAI,CAAC,CAAC,IAAF,IAAU,IAAnC,CAAb;IACA,OAAA,CAAA,0BAAA,CAA2B,aAAa,IAAI,aAA5C,EAA2D,MAA3D;IACA,OAAO,MAAP;EACH;;AA5ByB;;AAA9B,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AA+BA,SAAS,mBAAT,CAA6B,IAA7B,EAAsC;EAClC,IAAI,IAAI,CAAC,WAAL,CAAiB,MAAjB,KAA4B,SAA5B,IAAyC,IAAI,CAAC,WAAL,CAAiB,OAAjB,KAA6B,SAA1E,EAAqF;IACjF,OAAO,IAAP;EACH,CAHiC,CAKlC;;;EACA,IAAI,mBAAmB,GAAA,MAAA,CAAA,MAAA,CAAA;IAAK,IAAI,EAAE;EAAX,CAAA,EAA6B,IAAI,CAAC,WAAlC,CAAvB;EAEA,OAAO,UAAA,CAAA,kBAAA,CAAmB,QAAnB,CAA4B,mBAA5B,CAAP;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ContractInterface = void 0;\r\nconst utils_1 = require(\"../../utils\");\r\nconst endpoint_1 = require(\"./endpoint\");\r\nconst NamePlaceholder = \"?\";\r\n/**\r\n * An Interace represents a (sub)set of endpoints (with their signatures included) defined by a contract.\r\n */\r\nclass ContractInterface {\r\n    constructor(name, constructor_definition, endpoints) {\r\n        this.endpoints = [];\r\n        this.name = name;\r\n        this.constructorDefinition = constructor_definition;\r\n        this.endpoints = endpoints;\r\n    }\r\n    static fromJSON(json) {\r\n        json.name = json.name || NamePlaceholder;\r\n        json.endpoints = json.endpoints || [];\r\n        let constructorDefinition = constructorFromJSON(json);\r\n        let endpoints = json.endpoints.map(item => endpoint_1.EndpointDefinition.fromJSON(item));\r\n        return new ContractInterface(json.name, constructorDefinition, endpoints);\r\n    }\r\n    getConstructorDefinition() {\r\n        return this.constructorDefinition;\r\n    }\r\n    getEndpoint(name) {\r\n        let result = this.endpoints.find(e => e.name == name);\r\n        utils_1.guardValueIsSetWithMessage(`endpoint [${name}] not found`, result);\r\n        return result;\r\n    }\r\n}\r\nexports.ContractInterface = ContractInterface;\r\nfunction constructorFromJSON(json) {\r\n    if (json.constructor.inputs === undefined || json.constructor.outputs === undefined) {\r\n        return null;\r\n    }\r\n    // the name will be missing, so we add it manually\r\n    let constructorWithName = Object.assign({ name: \"constructor\" }, json.constructor);\r\n    return endpoint_1.EndpointDefinition.fromJSON(constructorWithName);\r\n}\r\n//# sourceMappingURL=contractInterface.js.map"]},"metadata":{},"sourceType":"script"}