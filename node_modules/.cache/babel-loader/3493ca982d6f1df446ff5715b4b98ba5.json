{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\n\nconst primitives_1 = require(\"./primitives\");\n\nconst WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\n\nclass TransactionCompletionStrategyOnProxy {\n  isCompleted(transaction) {\n    if (transaction.status.isPending()) {\n      // Certainly not completed.\n      return false;\n    } // Handle gateway mechanics:\n\n\n    for (const completionEvent of WellKnownCompletionEvents) {\n      if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n        // Certainly completed.\n        console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n        return true;\n      }\n    }\n\n    if (this.isCertainlyMoveBalance(transaction.data)) {\n      return transaction.status.isExecuted();\n    }\n\n    let hyperblockNonce = transaction.hyperblockNonce; // Imprecise condition, uncertain completion (usually sufficient, though).\n    // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n\n    if (hyperblockNonce > 0) {\n      console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n      return true;\n    }\n\n    return false;\n  }\n\n  isCertainlyMoveBalance(transactionData) {\n    let parts = transactionData.toString().split(\"@\");\n    let prefix = parts[0];\n    let otherParts = parts.slice(1);\n    let emptyPrefix = !prefix;\n    let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));\n    return emptyPrefix || somePartsAreNotValidArguments;\n  }\n\n  looksLikeValidArgument(arg) {\n    return primitives_1.isPaddedHex(arg);\n  }\n\n}\n\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\n\nclass TransactionCompletionStrategyOnAPI {\n  isCompleted(transaction) {\n    return !transaction.status.isPending();\n  }\n\n}\n\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;","map":{"version":3,"sources":["../src/transactionCompletionStrategy.ts"],"names":[],"mappings":";;;;;;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AASA,MAAM,yBAAyB,GAAG,CAAC,kBAAD,EAAqB,UAArB,EAAiC,aAAjC,CAAlC;AAEA;;;AAGG;;AACH,MAAa,oCAAb,CAAiD;EAC7C,WAAW,CAAC,WAAD,EAAmC;IAC1C,IAAI,WAAW,CAAC,MAAZ,CAAmB,SAAnB,EAAJ,EAAoC;MAChC;MACA,OAAO,KAAP;IACH,CAJyC,CAM1C;;;IACA,KAAK,MAAM,eAAX,IAA8B,yBAA9B,EAAyD;MACrD,IAAI,WAAW,CAAC,IAAZ,CAAiB,oBAAjB,CAAsC,eAAtC,CAAJ,EAA4D;QACxD;QACA,OAAO,CAAC,KAAR,CAAc,2DAAd,EAA2E,eAA3E;QACA,OAAO,IAAP;MACH;IACJ;;IAED,IAAI,KAAK,sBAAL,CAA4B,WAAW,CAAC,IAAxC,CAAJ,EAAmD;MAC/C,OAAO,WAAW,CAAC,MAAZ,CAAmB,UAAnB,EAAP;IACH;;IAED,IAAI,eAAe,GAAG,WAAW,CAAC,eAAlC,CAnB0C,CAqB1C;IACA;;IACA,IAAI,eAAe,GAAG,CAAtB,EAAyB;MACrB,OAAO,CAAC,KAAR,CAAc,sEAAd,EAAsF,eAAtF;MACA,OAAO,IAAP;IACH;;IAED,OAAO,KAAP;EACH;;EAEO,sBAAsB,CAAC,eAAD,EAAwB;IAClD,IAAI,KAAK,GAAG,eAAe,CAAC,QAAhB,GAA2B,KAA3B,CAAiC,GAAjC,CAAZ;IACA,IAAI,MAAM,GAAG,KAAK,CAAC,CAAD,CAAlB;IACA,IAAI,UAAU,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAjB;IACA,IAAI,WAAW,GAAG,CAAC,MAAnB;IACA,IAAI,6BAA6B,GAAG,CAAC,UAAU,CAAC,KAAX,CAAiB,IAAI,IAAI,KAAK,sBAAL,CAA4B,IAA5B,CAAzB,CAArC;IAEA,OAAO,WAAW,IAAI,6BAAtB;EACH;;EAEO,sBAAsB,CAAC,GAAD,EAAY;IACtC,OAAO,YAAA,CAAA,WAAA,CAAY,GAAZ,CAAP;EACH;;AA5C4C;;AAAjD,OAAA,CAAA,oCAAA,GAAA,oCAAA;;AA+CA,MAAa,kCAAb,CAA+C;EAC3C,WAAW,CAAC,WAAD,EAAmC;IAC1C,OAAO,CAAC,WAAW,CAAC,MAAZ,CAAmB,SAAnB,EAAR;EACH;;AAH0C;;AAA/C,OAAA,CAAA,kCAAA,GAAA,kCAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\nconst primitives_1 = require(\"./primitives\");\nconst WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\nclass TransactionCompletionStrategyOnProxy {\n    isCompleted(transaction) {\n        if (transaction.status.isPending()) {\n            // Certainly not completed.\n            return false;\n        }\n        // Handle gateway mechanics:\n        for (const completionEvent of WellKnownCompletionEvents) {\n            if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n                // Certainly completed.\n                console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n                return true;\n            }\n        }\n        if (this.isCertainlyMoveBalance(transaction.data)) {\n            return transaction.status.isExecuted();\n        }\n        let hyperblockNonce = transaction.hyperblockNonce;\n        // Imprecise condition, uncertain completion (usually sufficient, though).\n        // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n        if (hyperblockNonce > 0) {\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n            return true;\n        }\n        return false;\n    }\n    isCertainlyMoveBalance(transactionData) {\n        let parts = transactionData.toString().split(\"@\");\n        let prefix = parts[0];\n        let otherParts = parts.slice(1);\n        let emptyPrefix = !prefix;\n        let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));\n        return emptyPrefix || somePartsAreNotValidArguments;\n    }\n    looksLikeValidArgument(arg) {\n        return primitives_1.isPaddedHex(arg);\n    }\n}\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\nclass TransactionCompletionStrategyOnAPI {\n    isCompleted(transaction) {\n        return !transaction.status.isPending();\n    }\n}\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;\n//# sourceMappingURL=transactionCompletionStrategy.js.map"]},"metadata":{},"sourceType":"script"}