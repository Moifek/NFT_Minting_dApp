{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserPublicKey = exports.UserSecretKey = exports.USER_PUBKEY_LENGTH = exports.USER_SEED_LENGTH = void 0;\n\nconst tweetnacl = __importStar(require(\"tweetnacl\"));\n\nconst address_1 = require(\"../address\");\n\nconst utils_1 = require(\"../utils\");\n\nconst pem_1 = require(\"./pem\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.USER_SEED_LENGTH = 32;\nexports.USER_PUBKEY_LENGTH = 32;\n\nclass UserSecretKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_SEED_LENGTH);\n    this.buffer = buffer;\n  }\n\n  static fromString(value) {\n    utils_1.guardLength(value, exports.USER_SEED_LENGTH * 2);\n    let buffer = Buffer.from(value, \"hex\");\n    return new UserSecretKey(buffer);\n  }\n\n  static fromPem(text) {\n    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return pem_1.parseUserKey(text, index);\n  }\n\n  generatePublicKey() {\n    let keyPair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let buffer = Buffer.from(keyPair.publicKey);\n    return new UserPublicKey(buffer);\n  }\n\n  sign(message) {\n    let pair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\n    let signingKey = pair.secretKey;\n    let signature = tweetnacl.sign(new Uint8Array(message), signingKey); // \"tweetnacl.sign()\" returns the concatenated [signature, message], therfore we remove the appended message:\n\n    signature = signature.slice(0, signature.length - message.length);\n    return Buffer.from(signature);\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserSecretKey = UserSecretKey;\n\nclass UserPublicKey {\n  constructor(buffer) {\n    utils_1.guardLength(buffer, exports.USER_PUBKEY_LENGTH);\n    this.buffer = buffer;\n  }\n\n  verify(message, signature) {\n    try {\n      const unopenedMessage = Buffer.concat([signature, message]);\n      const unsignedMessage = tweetnacl.sign.open(unopenedMessage, this.buffer);\n      return unsignedMessage != null;\n    } catch (err) {\n      logger_1.Logger.error(err);\n      return false;\n    }\n  }\n\n  hex() {\n    return this.buffer.toString(\"hex\");\n  }\n\n  toAddress() {\n    return new address_1.Address(this.buffer);\n  }\n\n  valueOf() {\n    return this.buffer;\n  }\n\n}\n\nexports.UserPublicKey = UserPublicKey;","map":{"version":3,"sources":["../../src/walletcore/userKeys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UserPublicKey = exports.UserSecretKey = exports.USER_PUBKEY_LENGTH = exports.USER_SEED_LENGTH = void 0;\r\nconst tweetnacl = __importStar(require(\"tweetnacl\"));\r\nconst address_1 = require(\"../address\");\r\nconst utils_1 = require(\"../utils\");\r\nconst pem_1 = require(\"./pem\");\r\nconst logger_1 = require(\"../logger\");\r\nexports.USER_SEED_LENGTH = 32;\r\nexports.USER_PUBKEY_LENGTH = 32;\r\nclass UserSecretKey {\r\n    constructor(buffer) {\r\n        utils_1.guardLength(buffer, exports.USER_SEED_LENGTH);\r\n        this.buffer = buffer;\r\n    }\r\n    static fromString(value) {\r\n        utils_1.guardLength(value, exports.USER_SEED_LENGTH * 2);\r\n        let buffer = Buffer.from(value, \"hex\");\r\n        return new UserSecretKey(buffer);\r\n    }\r\n    static fromPem(text, index = 0) {\r\n        return pem_1.parseUserKey(text, index);\r\n    }\r\n    generatePublicKey() {\r\n        let keyPair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\r\n        let buffer = Buffer.from(keyPair.publicKey);\r\n        return new UserPublicKey(buffer);\r\n    }\r\n    sign(message) {\r\n        let pair = tweetnacl.sign.keyPair.fromSeed(new Uint8Array(this.buffer));\r\n        let signingKey = pair.secretKey;\r\n        let signature = tweetnacl.sign(new Uint8Array(message), signingKey);\r\n        // \"tweetnacl.sign()\" returns the concatenated [signature, message], therfore we remove the appended message:\r\n        signature = signature.slice(0, signature.length - message.length);\r\n        return Buffer.from(signature);\r\n    }\r\n    hex() {\r\n        return this.buffer.toString(\"hex\");\r\n    }\r\n    valueOf() {\r\n        return this.buffer;\r\n    }\r\n}\r\nexports.UserSecretKey = UserSecretKey;\r\nclass UserPublicKey {\r\n    constructor(buffer) {\r\n        utils_1.guardLength(buffer, exports.USER_PUBKEY_LENGTH);\r\n        this.buffer = buffer;\r\n    }\r\n    verify(message, signature) {\r\n        try {\r\n            const unopenedMessage = Buffer.concat([signature, message]);\r\n            const unsignedMessage = tweetnacl.sign.open(unopenedMessage, this.buffer);\r\n            return unsignedMessage != null;\r\n        }\r\n        catch (err) {\r\n            logger_1.Logger.error(err);\r\n            return false;\r\n        }\r\n    }\r\n    hex() {\r\n        return this.buffer.toString(\"hex\");\r\n    }\r\n    toAddress() {\r\n        return new address_1.Address(this.buffer);\r\n    }\r\n    valueOf() {\r\n        return this.buffer;\r\n    }\r\n}\r\nexports.UserPublicKey = UserPublicKey;\r\n//# sourceMappingURL=userKeys.js.map"]},"metadata":{},"sourceType":"script"}