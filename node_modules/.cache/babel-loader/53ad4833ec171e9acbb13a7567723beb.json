{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListBinaryCodec = void 0;\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst constants_1 = require(\"./constants\");\n/**\r\n * Encodes and decodes \"List\" objects\r\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\r\n */\n\n\nclass ListBinaryCodec {\n  constructor(binaryCodec) {\n    this.binaryCodec = binaryCodec;\n  }\n\n  decodeNested(buffer, type) {\n    let typeParameter = type.getFirstTypeParameter();\n    let result = [];\n    let numItems = buffer.readUInt32BE(0);\n    this.binaryCodec.constraints.checkListLength(numItems);\n    let originalBuffer = buffer;\n    let offset = constants_1.SizeOfU32;\n    buffer = originalBuffer.slice(offset);\n\n    for (let i = 0; i < numItems; i++) {\n      let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n      result.push(decoded);\n      offset += decodedLength;\n      buffer = originalBuffer.slice(offset);\n    }\n\n    return [new typesystem_1.List(type, result), offset];\n  }\n\n  decodeTopLevel(buffer, type) {\n    let typeParameter = type.getFirstTypeParameter();\n    let result = [];\n    let originalBuffer = buffer;\n    let offset = 0;\n\n    while (buffer.length > 0) {\n      let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n      result.push(decoded);\n      offset += decodedLength;\n      buffer = originalBuffer.slice(offset);\n      this.binaryCodec.constraints.checkListLength(result.length);\n    }\n\n    return new typesystem_1.List(type, result);\n  }\n\n  encodeNested(list) {\n    this.binaryCodec.constraints.checkListLength(list.getLength());\n    let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n    lengthBuffer.writeUInt32BE(list.getLength());\n    let itemsBuffers = [];\n\n    for (const item of list.getItems()) {\n      let itemBuffer = this.binaryCodec.encodeNested(item);\n      itemsBuffers.push(itemBuffer);\n    }\n\n    let buffer = Buffer.concat([lengthBuffer, ...itemsBuffers]);\n    return buffer;\n  }\n\n  encodeTopLevel(list) {\n    this.binaryCodec.constraints.checkListLength(list.getLength());\n    let itemsBuffers = [];\n\n    for (const item of list.getItems()) {\n      let itemBuffer = this.binaryCodec.encodeNested(item);\n      itemsBuffers.push(itemBuffer);\n    }\n\n    let buffer = Buffer.concat(itemsBuffers);\n    return buffer;\n  }\n\n}\n\nexports.ListBinaryCodec = ListBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/list.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ListBinaryCodec = void 0;\r\nconst typesystem_1 = require(\"../typesystem\");\r\nconst constants_1 = require(\"./constants\");\r\n/**\r\n * Encodes and decodes \"List\" objects\r\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\r\n */\r\nclass ListBinaryCodec {\r\n    constructor(binaryCodec) {\r\n        this.binaryCodec = binaryCodec;\r\n    }\r\n    decodeNested(buffer, type) {\r\n        let typeParameter = type.getFirstTypeParameter();\r\n        let result = [];\r\n        let numItems = buffer.readUInt32BE(0);\r\n        this.binaryCodec.constraints.checkListLength(numItems);\r\n        let originalBuffer = buffer;\r\n        let offset = constants_1.SizeOfU32;\r\n        buffer = originalBuffer.slice(offset);\r\n        for (let i = 0; i < numItems; i++) {\r\n            let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\r\n            result.push(decoded);\r\n            offset += decodedLength;\r\n            buffer = originalBuffer.slice(offset);\r\n        }\r\n        return [new typesystem_1.List(type, result), offset];\r\n    }\r\n    decodeTopLevel(buffer, type) {\r\n        let typeParameter = type.getFirstTypeParameter();\r\n        let result = [];\r\n        let originalBuffer = buffer;\r\n        let offset = 0;\r\n        while (buffer.length > 0) {\r\n            let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\r\n            result.push(decoded);\r\n            offset += decodedLength;\r\n            buffer = originalBuffer.slice(offset);\r\n            this.binaryCodec.constraints.checkListLength(result.length);\r\n        }\r\n        return new typesystem_1.List(type, result);\r\n    }\r\n    encodeNested(list) {\r\n        this.binaryCodec.constraints.checkListLength(list.getLength());\r\n        let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\r\n        lengthBuffer.writeUInt32BE(list.getLength());\r\n        let itemsBuffers = [];\r\n        for (const item of list.getItems()) {\r\n            let itemBuffer = this.binaryCodec.encodeNested(item);\r\n            itemsBuffers.push(itemBuffer);\r\n        }\r\n        let buffer = Buffer.concat([lengthBuffer, ...itemsBuffers]);\r\n        return buffer;\r\n    }\r\n    encodeTopLevel(list) {\r\n        this.binaryCodec.constraints.checkListLength(list.getLength());\r\n        let itemsBuffers = [];\r\n        for (const item of list.getItems()) {\r\n            let itemBuffer = this.binaryCodec.encodeNested(item);\r\n            itemsBuffers.push(itemBuffer);\r\n        }\r\n        let buffer = Buffer.concat(itemsBuffers);\r\n        return buffer;\r\n    }\r\n}\r\nexports.ListBinaryCodec = ListBinaryCodec;\r\n//# sourceMappingURL=list.js.map"]},"metadata":{},"sourceType":"script"}