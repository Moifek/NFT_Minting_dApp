{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nconst fields_1 = require(\"./fields\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fieldsDefinitions) {\n    super(name);\n    this.fieldsDefinitions = [];\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n\n  getClassName() {\n    return StructType.ClassName;\n  }\n\n  static fromJSON(json) {\n    let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n    return new StructType(json.name, definitions);\n  }\n\n  getFieldsDefinitions() {\n    return this.fieldsDefinitions;\n  }\n\n}\n\nexports.StructType = StructType;\nStructType.ClassName = \"StructType\"; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\r\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\r\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  getClassName() {\n    return Struct.ClassName;\n  }\n\n  checkTyping() {\n    let type = this.getType();\n    let definitions = type.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(this.fields, definitions);\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n    return fields_1.Fields.equals(selfFields, otherFields);\n  }\n\n}\n\nexports.Struct = Struct;\nStruct.ClassName = \"Struct\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAa,UAAb,SAAgC,OAAA,CAAA,UAAhC,CAA0C;EAItC,WAAA,CAAY,IAAZ,EAA0B,iBAA1B,EAA8D;IAC1D,MAAM,IAAN;IAHa,KAAA,iBAAA,GAAuC,EAAvC;IAIb,KAAK,iBAAL,GAAyB,iBAAzB;EACH;;EAED,YAAY,GAAA;IACR,OAAO,UAAU,CAAC,SAAlB;EACH;;EAEc,OAAR,QAAQ,CAAC,IAAD,EAAsC;IACjD,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAwB,UAAU,IAAI,QAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,UAAzB,CAAtC,CAAlB;IACA,OAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,IAApB,EAA0B,WAA1B,CAAP;EACH;;EAED,oBAAoB,GAAA;IAChB,OAAO,KAAK,iBAAZ;EACH;;AApBqC;;AAA1C,OAAA,CAAA,UAAA,GAAA,UAAA;AACW,UAAA,CAAA,SAAA,GAAY,YAAZ,C,CAsBX;AACA;;AACA,MAAa,MAAb,SAA4B,OAAA,CAAA,UAA5B,CAAsC;EAIlC;;AAEG;EACH,WAAA,CAAY,IAAZ,EAA8B,MAA9B,EAA6C;IACzC,MAAM,IAAN;IANa,KAAA,MAAA,GAAkB,EAAlB;IAOb,KAAK,MAAL,GAAc,MAAd;IAEA,KAAK,WAAL;EACH;;EAED,YAAY,GAAA;IACR,OAAO,MAAM,CAAC,SAAd;EACH;;EAEO,WAAW,GAAA;IACf,IAAI,IAAI,GAAe,KAAK,OAAL,EAAvB;IACA,IAAI,WAAW,GAAG,IAAI,CAAC,oBAAL,EAAlB;IACA,QAAA,CAAA,MAAA,CAAO,WAAP,CAAmB,KAAK,MAAxB,EAAgC,WAAhC;EACH;;EAED,SAAS,GAAA;IACL,OAAO,KAAK,MAAZ;EACH;;EAED,OAAO,GAAA;IACH,IAAI,MAAM,GAAQ,EAAlB;;IAEA,KAAK,MAAM,KAAX,IAAoB,KAAK,MAAzB,EAAiC;MAC7B,MAAM,CAAC,KAAK,CAAC,IAAP,CAAN,GAAqB,KAAK,CAAC,KAAN,CAAY,OAAZ,EAArB;IACH;;IAED,OAAO,MAAP;EACH;;EAED,MAAM,CAAC,KAAD,EAAc;IAChB,IAAI,CAAC,KAAK,OAAL,GAAe,MAAf,CAAsB,KAAK,CAAC,OAAN,EAAtB,CAAL,EAA6C;MACzC,OAAO,KAAP;IACH;;IAED,IAAI,UAAU,GAAG,KAAK,SAAL,EAAjB;IACA,IAAI,WAAW,GAAG,KAAK,CAAC,SAAN,EAAlB;IAEA,OAAO,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,UAAd,EAA0B,WAA1B,CAAP;EACH;;AA/CiC;;AAAtC,OAAA,CAAA,MAAA,GAAA,MAAA;AACW,MAAA,CAAA,SAAA,GAAY,QAAZ","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Struct = exports.StructType = void 0;\r\nconst fields_1 = require(\"./fields\");\r\nconst types_1 = require(\"./types\");\r\nclass StructType extends types_1.CustomType {\r\n    constructor(name, fieldsDefinitions) {\r\n        super(name);\r\n        this.fieldsDefinitions = [];\r\n        this.fieldsDefinitions = fieldsDefinitions;\r\n    }\r\n    getClassName() {\r\n        return StructType.ClassName;\r\n    }\r\n    static fromJSON(json) {\r\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\r\n        return new StructType(json.name, definitions);\r\n    }\r\n    getFieldsDefinitions() {\r\n        return this.fieldsDefinitions;\r\n    }\r\n}\r\nexports.StructType = StructType;\r\nStructType.ClassName = \"StructType\";\r\n// TODO: implement setField(), convenience method.\r\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\r\nclass Struct extends types_1.TypedValue {\r\n    /**\r\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\r\n     */\r\n    constructor(type, fields) {\r\n        super(type);\r\n        this.fields = [];\r\n        this.fields = fields;\r\n        this.checkTyping();\r\n    }\r\n    getClassName() {\r\n        return Struct.ClassName;\r\n    }\r\n    checkTyping() {\r\n        let type = this.getType();\r\n        let definitions = type.getFieldsDefinitions();\r\n        fields_1.Fields.checkTyping(this.fields, definitions);\r\n    }\r\n    getFields() {\r\n        return this.fields;\r\n    }\r\n    valueOf() {\r\n        let result = {};\r\n        for (const field of this.fields) {\r\n            result[field.name] = field.value.valueOf();\r\n        }\r\n        return result;\r\n    }\r\n    equals(other) {\r\n        if (!this.getType().equals(other.getType())) {\r\n            return false;\r\n        }\r\n        let selfFields = this.getFields();\r\n        let otherFields = other.getFields();\r\n        return fields_1.Fields.equals(selfFields, otherFields);\r\n    }\r\n}\r\nexports.Struct = Struct;\r\nStruct.ClassName = \"Struct\";\r\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}