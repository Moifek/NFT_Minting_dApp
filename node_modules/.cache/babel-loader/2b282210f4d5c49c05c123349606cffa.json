{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst utils_1 = require(\"../../utils\");\n\nconst struct_1 = require(\"./struct\");\n\nconst contractInterface_1 = require(\"./contractInterface\");\n\nconst enum_1 = require(\"./enum\");\n\nconst typeMapper_1 = require(\"./typeMapper\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nclass AbiRegistry {\n  constructor() {\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  /**\r\n   * Convenience factory function to load ABIs (from files or URLs).\r\n   * This function will also remap ABI types to know types (on best-efforts basis).\r\n   */\n\n\n  static load(json) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let registry = new AbiRegistry();\n\n      for (const file of json.files || []) {\n        yield registry.extendFromFile(file);\n      }\n\n      for (const url of json.urls || []) {\n        yield registry.extendFromUrl(url);\n      }\n\n      registry = registry.remapToKnownTypes();\n      return registry;\n    });\n  }\n  /**\r\n   * Generally, one should use {@link AbiRegistry.load} instead.\r\n   */\n\n\n  extendFromFile(file) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let jsonContent = yield fs.promises.readFile(file, {\n        encoding: \"utf8\"\n      });\n      let json = JSON.parse(jsonContent);\n      return this.extend(json);\n    });\n  }\n  /**\r\n   * Generally, one should use {@link AbiRegistry.load} instead.\r\n   */\n\n\n  extendFromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let response = yield axios_1.default.get(url);\n      let json = response.data;\n      return this.extend(json);\n    });\n  }\n\n  extend(json) {\n    json.types = json.types || {}; // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n\n    let iface = contractInterface_1.ContractInterface.fromJSON(json);\n    this.interfaces.push(iface);\n\n    for (const customTypeName in json.types) {\n      let itemJson = json.types[customTypeName];\n      let typeDiscriminant = itemJson.type; // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n\n      itemJson.name = customTypeName;\n      let customType = this.createCustomType(typeDiscriminant, itemJson);\n      this.customTypes.push(customType);\n    }\n\n    return this;\n  }\n\n  createCustomType(typeDiscriminant, json) {\n    if (typeDiscriminant == \"struct\") {\n      return struct_1.StructType.fromJSON(json);\n    }\n\n    if (typeDiscriminant == \"enum\") {\n      return enum_1.EnumType.fromJSON(json);\n    }\n\n    throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n  }\n\n  getInterface(name) {\n    let result = this.interfaces.find(e => e.name == name);\n    utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n    return result;\n  }\n\n  getInterfaces(names) {\n    return names.map(name => this.getInterface(name));\n  }\n\n  getStruct(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName));\n    utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n    return result;\n  }\n\n  getStructs(names) {\n    return names.map(name => this.getStruct(name));\n  }\n\n  getEnum(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName));\n    utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n    return result;\n  }\n\n  getEnums(names) {\n    return names.map(name => this.getEnum(name));\n  }\n  /**\r\n   * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\r\n   * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\r\n   *\r\n   * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\r\n   *\r\n   * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\r\n   * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\r\n   * The result is an equivalent, more explicit ABI registry.\r\n   */\n\n\n  remapToKnownTypes() {\n    let mapper = new typeMapper_1.TypeMapper(this.customTypes);\n    let newCustomTypes = [];\n    let newInterfaces = []; // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n\n    for (const type of this.customTypes) {\n      const mappedTyped = mapper.mapType(type);\n      newCustomTypes.push(mappedTyped);\n      mapper.feedCustomType(mappedTyped);\n    } // Then, remap types of all endpoint parameters.\n    // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n\n\n    mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n\n    for (const iface of this.interfaces) {\n      let newEndpoints = [];\n\n      for (const endpoint of iface.endpoints) {\n        newEndpoints.push(mapEndpoint(endpoint, mapper));\n      }\n\n      let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n      newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n    } // Now return the new registry, with all types remapped to known types\n\n\n    let newRegistry = new AbiRegistry();\n    newRegistry.customTypes.push(...newCustomTypes);\n    newRegistry.interfaces.push(...newInterfaces);\n    return newRegistry;\n  }\n\n}\n\nexports.AbiRegistry = AbiRegistry;\n\nfunction mapEndpoint(endpoint, mapper) {\n  let newInput = endpoint.input.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  let newOutput = endpoint.output.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,EAAA,GAAA,YAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAa,WAAb,CAAwB;EAAxB,WAAA,GAAA;IACa,KAAA,UAAA,GAAkC,EAAlC;IACA,KAAA,WAAA,GAA4B,EAA5B;EAsHZ;EArHG;;;AAGG;;;EACc,OAAJ,IAAI,CAAC,IAAD,EAA4C;;MACzD,IAAI,QAAQ,GAAG,IAAI,WAAJ,EAAf;;MACA,KAAK,MAAM,IAAX,IAAmB,IAAI,CAAC,KAAL,IAAc,EAAjC,EAAqC;QACjC,MAAM,QAAQ,CAAC,cAAT,CAAwB,IAAxB,CAAN;MACH;;MACD,KAAK,MAAM,GAAX,IAAkB,IAAI,CAAC,IAAL,IAAa,EAA/B,EAAmC;QAC/B,MAAM,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAAN;MACH;;MACD,QAAQ,GAAG,QAAQ,CAAC,iBAAT,EAAX;MACA,OAAO,QAAP;IACH,C;EAAA;EACD;;AAEG;;;EACG,cAAc,CAAC,IAAD,EAAa;;MAC7B,IAAI,WAAW,GAAW,MAAM,EAAE,CAAC,QAAH,CAAY,QAAZ,CAAqB,IAArB,EAA2B;QAAE,QAAQ,EAAE;MAAZ,CAA3B,CAAhC;MACA,IAAI,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,WAAX,CAAX;MACA,OAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;IACH,C;EAAA;EACD;;AAEG;;;EACG,aAAa,CAAC,GAAD,EAAY;;MAC3B,IAAI,QAAQ,GAAkB,MAAM,OAAA,CAAA,OAAA,CAAM,GAAN,CAAU,GAAV,CAApC;MACA,IAAI,IAAI,GAAG,QAAQ,CAAC,IAApB;MACA,OAAO,KAAK,MAAL,CAAY,IAAZ,CAAP;IACH,C;EAAA;;EACD,MAAM,CAAC,IAAD,EAAuD;IACzD,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,KAAL,IAAc,EAA3B,CADyD,CAEzD;;IACA,IAAI,KAAK,GAAG,mBAAA,CAAA,iBAAA,CAAkB,QAAlB,CAA2B,IAA3B,CAAZ;IACA,KAAK,UAAL,CAAgB,IAAhB,CAAqB,KAArB;;IACA,KAAK,MAAM,cAAX,IAA6B,IAAI,CAAC,KAAlC,EAAyC;MACrC,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,cAAX,CAAf;MACA,IAAI,gBAAgB,GAAG,QAAQ,CAAC,IAAhC,CAFqC,CAGrC;;MACA,QAAQ,CAAC,IAAT,GAAgB,cAAhB;MACA,IAAI,UAAU,GAAG,KAAK,gBAAL,CAAsB,gBAAtB,EAAwC,QAAxC,CAAjB;MACA,KAAK,WAAL,CAAiB,IAAjB,CAAsB,UAAtB;IACH;;IACD,OAAO,IAAP;EACH;;EACO,gBAAgB,CAAC,gBAAD,EAA2B,IAA3B,EAAoC;IACxD,IAAI,gBAAgB,IAAI,QAAxB,EAAkC;MAC9B,OAAO,QAAA,CAAA,UAAA,CAAW,QAAX,CAAoB,IAApB,CAAP;IACH;;IACD,IAAI,gBAAgB,IAAI,MAAxB,EAAgC;MAC5B,OAAO,MAAA,CAAA,QAAA,CAAS,QAAT,CAAkB,IAAlB,CAAP;IACH;;IACD,MAAM,IAAI,MAAM,CAAC,eAAX,CAA2B,8BAA8B,gBAAgB,EAAzE,CAAN;EACH;;EACD,YAAY,CAAC,IAAD,EAAa;IACrB,IAAI,MAAM,GAAG,KAAK,UAAL,CAAgB,IAAhB,CAAsB,CAAD,IAAO,CAAC,CAAC,IAAF,IAAU,IAAtC,CAAb;IACA,OAAA,CAAA,0BAAA,CAA2B,cAAc,IAAI,aAA7C,EAA4D,MAA5D;IACA,OAAO,MAAP;EACH;;EACD,aAAa,CAAC,KAAD,EAAgB;IACzB,OAAO,KAAK,CAAC,GAAN,CAAW,IAAD,IAAU,KAAK,YAAL,CAAkB,IAAlB,CAApB,CAAP;EACH;;EACD,SAAS,CAAC,IAAD,EAAa;IAClB,IAAI,MAAM,GAAG,KAAK,WAAL,CAAiB,IAAjB,CAAuB,CAAD,IAAO,CAAC,CAAC,OAAF,MAAe,IAAf,IAAuB,CAAC,CAAC,aAAF,CAAgB,QAAA,CAAA,UAAA,CAAW,SAA3B,CAApD,CAAb;IACA,OAAA,CAAA,0BAAA,CAA2B,WAAW,IAAI,aAA1C,EAAyD,MAAzD;IACA,OAAmB,MAAnB;EACH;;EACD,UAAU,CAAC,KAAD,EAAgB;IACtB,OAAO,KAAK,CAAC,GAAN,CAAW,IAAD,IAAU,KAAK,SAAL,CAAe,IAAf,CAApB,CAAP;EACH;;EACD,OAAO,CAAC,IAAD,EAAa;IAChB,IAAI,MAAM,GAAG,KAAK,WAAL,CAAiB,IAAjB,CAAuB,CAAD,IAAO,CAAC,CAAC,OAAF,MAAe,IAAf,IAAuB,CAAC,CAAC,aAAF,CAAgB,MAAA,CAAA,QAAA,CAAS,SAAzB,CAApD,CAAb;IACA,OAAA,CAAA,0BAAA,CAA2B,SAAS,IAAI,aAAxC,EAAuD,MAAvD;IACA,OAAiB,MAAjB;EACH;;EACD,QAAQ,CAAC,KAAD,EAAgB;IACpB,OAAO,KAAK,CAAC,GAAN,CAAW,IAAD,IAAU,KAAK,OAAL,CAAa,IAAb,CAApB,CAAP;EACH;EACD;;;;;;;;;AASG;;;EACH,iBAAiB,GAAA;IACb,IAAI,MAAM,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,KAAK,WAApB,CAAb;IACA,IAAI,cAAc,GAAiB,EAAnC;IACA,IAAI,aAAa,GAAwB,EAAzC,CAHa,CAIb;;IACA,KAAK,MAAM,IAAX,IAAmB,KAAK,WAAxB,EAAqC;MACjC,MAAM,WAAW,GAAG,MAAM,CAAC,OAAP,CAAe,IAAf,CAApB;MACA,cAAc,CAAC,IAAf,CAAoB,WAApB;MACA,MAAM,CAAC,cAAP,CAAsB,WAAtB;IACH,CATY,CAUb;IACA;;;IACA,MAAM,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,cAAf,CAAT;;IACA,KAAK,MAAM,KAAX,IAAoB,KAAK,UAAzB,EAAqC;MACjC,IAAI,YAAY,GAAyB,EAAzC;;MACA,KAAK,MAAM,QAAX,IAAuB,KAAK,CAAC,SAA7B,EAAwC;QACpC,YAAY,CAAC,IAAb,CAAkB,WAAW,CAAC,QAAD,EAAW,MAAX,CAA7B;MACH;;MACD,IAAI,cAAc,GAAG,KAAK,CAAC,qBAAN,GAA8B,WAAW,CAAC,KAAK,CAAC,qBAAP,EAA8B,MAA9B,CAAzC,GAAiF,IAAtG;MACA,aAAa,CAAC,IAAd,CAAmB,IAAI,mBAAA,CAAA,iBAAJ,CAAsB,KAAK,CAAC,IAA5B,EAAkC,cAAlC,EAAkD,YAAlD,CAAnB;IACH,CApBY,CAqBb;;;IACA,IAAI,WAAW,GAAG,IAAI,WAAJ,EAAlB;IACA,WAAW,CAAC,WAAZ,CAAwB,IAAxB,CAA6B,GAAG,cAAhC;IACA,WAAW,CAAC,UAAZ,CAAuB,IAAvB,CAA4B,GAAG,aAA/B;IAEA,OAAO,WAAP;EACH;;AAvHmB;;AAAxB,OAAA,CAAA,WAAA,GAAA,WAAA;;AA0HA,SAAS,WAAT,CAAqB,QAArB,EAAmD,MAAnD,EAAqE;EACjE,IAAI,QAAQ,GAAG,QAAQ,CAAC,KAAT,CAAe,GAAf,CACV,CAAD,IAAO,IAAI,UAAA,CAAA,2BAAJ,CAAgC,CAAC,CAAC,IAAlC,EAAwC,CAAC,CAAC,WAA1C,EAAuD,MAAM,CAAC,OAAP,CAAe,CAAC,CAAC,IAAjB,CAAvD,CADI,CAAf;EAGA,IAAI,SAAS,GAAG,QAAQ,CAAC,MAAT,CAAgB,GAAhB,CACX,CAAD,IAAO,IAAI,UAAA,CAAA,2BAAJ,CAAgC,CAAC,CAAC,IAAlC,EAAwC,CAAC,CAAC,WAA1C,EAAuD,MAAM,CAAC,OAAP,CAAe,CAAC,CAAC,IAAjB,CAAvD,CADK,CAAhB;EAGA,OAAO,IAAI,UAAA,CAAA,kBAAJ,CAAuB,QAAQ,CAAC,IAAhC,EAAsC,QAAtC,EAAgD,SAAhD,EAA2D,QAAQ,CAAC,SAApE,CAAP;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AbiRegistry = void 0;\r\nconst fs = __importStar(require(\"fs\"));\r\nconst errors = __importStar(require(\"../../errors\"));\r\nconst axios_1 = __importDefault(require(\"axios\"));\r\nconst utils_1 = require(\"../../utils\");\r\nconst struct_1 = require(\"./struct\");\r\nconst contractInterface_1 = require(\"./contractInterface\");\r\nconst enum_1 = require(\"./enum\");\r\nconst typeMapper_1 = require(\"./typeMapper\");\r\nconst endpoint_1 = require(\"./endpoint\");\r\nclass AbiRegistry {\r\n    constructor() {\r\n        this.interfaces = [];\r\n        this.customTypes = [];\r\n    }\r\n    /**\r\n     * Convenience factory function to load ABIs (from files or URLs).\r\n     * This function will also remap ABI types to know types (on best-efforts basis).\r\n     */\r\n    static load(json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let registry = new AbiRegistry();\r\n            for (const file of json.files || []) {\r\n                yield registry.extendFromFile(file);\r\n            }\r\n            for (const url of json.urls || []) {\r\n                yield registry.extendFromUrl(url);\r\n            }\r\n            registry = registry.remapToKnownTypes();\r\n            return registry;\r\n        });\r\n    }\r\n    /**\r\n     * Generally, one should use {@link AbiRegistry.load} instead.\r\n     */\r\n    extendFromFile(file) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let jsonContent = yield fs.promises.readFile(file, { encoding: \"utf8\" });\r\n            let json = JSON.parse(jsonContent);\r\n            return this.extend(json);\r\n        });\r\n    }\r\n    /**\r\n     * Generally, one should use {@link AbiRegistry.load} instead.\r\n     */\r\n    extendFromUrl(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let response = yield axios_1.default.get(url);\r\n            let json = response.data;\r\n            return this.extend(json);\r\n        });\r\n    }\r\n    extend(json) {\r\n        json.types = json.types || {};\r\n        // The \"endpoints\" collection is interpreted by \"ContractInterface\".\r\n        let iface = contractInterface_1.ContractInterface.fromJSON(json);\r\n        this.interfaces.push(iface);\r\n        for (const customTypeName in json.types) {\r\n            let itemJson = json.types[customTypeName];\r\n            let typeDiscriminant = itemJson.type;\r\n            // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\r\n            itemJson.name = customTypeName;\r\n            let customType = this.createCustomType(typeDiscriminant, itemJson);\r\n            this.customTypes.push(customType);\r\n        }\r\n        return this;\r\n    }\r\n    createCustomType(typeDiscriminant, json) {\r\n        if (typeDiscriminant == \"struct\") {\r\n            return struct_1.StructType.fromJSON(json);\r\n        }\r\n        if (typeDiscriminant == \"enum\") {\r\n            return enum_1.EnumType.fromJSON(json);\r\n        }\r\n        throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\r\n    }\r\n    getInterface(name) {\r\n        let result = this.interfaces.find((e) => e.name == name);\r\n        utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\r\n        return result;\r\n    }\r\n    getInterfaces(names) {\r\n        return names.map((name) => this.getInterface(name));\r\n    }\r\n    getStruct(name) {\r\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName));\r\n        utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\r\n        return result;\r\n    }\r\n    getStructs(names) {\r\n        return names.map((name) => this.getStruct(name));\r\n    }\r\n    getEnum(name) {\r\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName));\r\n        utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\r\n        return result;\r\n    }\r\n    getEnums(names) {\r\n        return names.map((name) => this.getEnum(name));\r\n    }\r\n    /**\r\n     * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\r\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\r\n     *\r\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\r\n     *\r\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\r\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\r\n     * The result is an equivalent, more explicit ABI registry.\r\n     */\r\n    remapToKnownTypes() {\r\n        let mapper = new typeMapper_1.TypeMapper(this.customTypes);\r\n        let newCustomTypes = [];\r\n        let newInterfaces = [];\r\n        // First, remap custom types (actually, under the hood, this will remap types of struct fields)\r\n        for (const type of this.customTypes) {\r\n            const mappedTyped = mapper.mapType(type);\r\n            newCustomTypes.push(mappedTyped);\r\n            mapper.feedCustomType(mappedTyped);\r\n        }\r\n        // Then, remap types of all endpoint parameters.\r\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\r\n        mapper = new typeMapper_1.TypeMapper(newCustomTypes);\r\n        for (const iface of this.interfaces) {\r\n            let newEndpoints = [];\r\n            for (const endpoint of iface.endpoints) {\r\n                newEndpoints.push(mapEndpoint(endpoint, mapper));\r\n            }\r\n            let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\r\n            newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\r\n        }\r\n        // Now return the new registry, with all types remapped to known types\r\n        let newRegistry = new AbiRegistry();\r\n        newRegistry.customTypes.push(...newCustomTypes);\r\n        newRegistry.interfaces.push(...newInterfaces);\r\n        return newRegistry;\r\n    }\r\n}\r\nexports.AbiRegistry = AbiRegistry;\r\nfunction mapEndpoint(endpoint, mapper) {\r\n    let newInput = endpoint.input.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\r\n    let newOutput = endpoint.output.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\r\n    return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\r\n}\r\n//# sourceMappingURL=abiRegistry.js.map"]},"metadata":{},"sourceType":"script"}