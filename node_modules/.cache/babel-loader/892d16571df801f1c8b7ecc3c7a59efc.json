{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FormattedCall = exports.formatEndpoint = void 0;\n\nconst argSerializer_1 = require(\"../argSerializer\");\n\nconst function_1 = require(\"../function\");\n\nconst nativeSerializer_1 = require(\"../nativeSerializer\");\n/**\r\n * Creates a FormattedCall from the given endpoint and args.\r\n */\n\n\nfunction formatEndpoint(executingEndpoint, interpretingEndpoint) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return new FormattedCall(executingEndpoint, interpretingEndpoint, args);\n}\n\nexports.formatEndpoint = formatEndpoint;\n/**\r\n * Formats and validates the arguments of a bound call.\r\n * A bound call is represented by a function and its arguments packed together.\r\n * A function is defined as something that has an EndpointDefinition and may be:\r\n * - a smart contract method\r\n * - a built-in function (such as an ESDT transfer)\r\n */\n\nclass FormattedCall {\n  constructor(executingEndpoint, interpretingEndpoint, args) {\n    this.executingEndpoint = executingEndpoint;\n    this.interpretingEndpoint = interpretingEndpoint;\n    this.args = args;\n  }\n\n  getExecutingFunction() {\n    return new function_1.ContractFunction(this.executingEndpoint.name);\n  }\n\n  getInterpretingFunction() {\n    return new function_1.ContractFunction(this.interpretingEndpoint.name);\n  }\n  /**\r\n   * Takes the given arguments, and converts them to typed values, validating them against the given endpoint in the process.\r\n   */\n\n\n  toTypedValues() {\n    let expandedArgs = this.getExpandedArgs();\n    return nativeSerializer_1.NativeSerializer.nativeToTypedValues(expandedArgs, this.executingEndpoint);\n  }\n\n  toArgBuffers() {\n    let typedValues = this.toTypedValues();\n    return new argSerializer_1.ArgSerializer().valuesToBuffers(typedValues);\n  }\n  /**\r\n   * Formats the function name and its arguments as an array of buffers.\r\n   * This is useful for nested calls (for the multisig smart contract or for ESDT transfers).\r\n   * A formatted deploy call does not return the function name.\r\n   */\n\n\n  toCallBuffers() {\n    if (this.executingEndpoint.isConstructor()) {\n      return this.toArgBuffers();\n    }\n\n    return [Buffer.from(this.executingEndpoint.name), ...this.toArgBuffers()];\n  }\n\n  getExpandedArgs() {\n    let expanded = [];\n\n    for (let value of this.args) {\n      if (value instanceof FormattedCall) {\n        expanded = expanded.concat(value.toCallBuffers());\n      } else {\n        expanded.push(value);\n      }\n    }\n\n    return expanded;\n  }\n\n}\n\nexports.FormattedCall = FormattedCall;","map":{"version":3,"sources":["../../../src/smartcontracts/wrapper/formattedCall.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,eAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AAGA;;AAEG;;;AACH,SAAgB,cAAhB,CAA+B,iBAA/B,EAAsE,oBAAtE,EAA8H;EAAA,kCAAX,IAAW;IAAX,IAAW;EAAA;;EAC1H,OAAO,IAAI,aAAJ,CAAkB,iBAAlB,EAAqC,oBAArC,EAA2D,IAA3D,CAAP;AACH;;AAFD,OAAA,CAAA,cAAA,GAAA,cAAA;AAIA;;;;;;AAMG;;AACH,MAAa,aAAb,CAA0B;EAKtB,WAAA,CAAY,iBAAZ,EAAmD,oBAAnD,EAA6F,IAA7F,EAAwG;IACpG,KAAK,iBAAL,GAAyB,iBAAzB;IACA,KAAK,oBAAL,GAA4B,oBAA5B;IACA,KAAK,IAAL,GAAY,IAAZ;EACH;;EAED,oBAAoB,GAAA;IAChB,OAAO,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,iBAAL,CAAuB,IAA5C,CAAP;EACH;;EAED,uBAAuB,GAAA;IACnB,OAAO,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,oBAAL,CAA0B,IAA/C,CAAP;EACH;EAED;;AAEG;;;EACH,aAAa,GAAA;IACT,IAAI,YAAY,GAAG,KAAK,eAAL,EAAnB;IACA,OAAO,kBAAA,CAAA,gBAAA,CAAiB,mBAAjB,CAAqC,YAArC,EAAmD,KAAK,iBAAxD,CAAP;EACH;;EAED,YAAY,GAAA;IACR,IAAI,WAAW,GAAG,KAAK,aAAL,EAAlB;IACA,OAAO,IAAI,eAAA,CAAA,aAAJ,GAAoB,eAApB,CAAoC,WAApC,CAAP;EACH;EAED;;;;AAIG;;;EACH,aAAa,GAAA;IACT,IAAI,KAAK,iBAAL,CAAuB,aAAvB,EAAJ,EAA4C;MACxC,OAAO,KAAK,YAAL,EAAP;IACH;;IACD,OAAO,CAAC,MAAM,CAAC,IAAP,CAAY,KAAK,iBAAL,CAAuB,IAAnC,CAAD,EAA2C,GAAG,KAAK,YAAL,EAA9C,CAAP;EACH;;EAEO,eAAe,GAAA;IACnB,IAAI,QAAQ,GAAU,EAAtB;;IACA,KAAK,IAAI,KAAT,IAAkB,KAAK,IAAvB,EAA6B;MACzB,IAAI,KAAK,YAAY,aAArB,EAAoC;QAChC,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAAC,aAAN,EAAhB,CAAX;MACH,CAFD,MAEO;QACH,QAAQ,CAAC,IAAT,CAAc,KAAd;MACH;IACJ;;IACD,OAAO,QAAP;EACH;;AAtDqB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FormattedCall = exports.formatEndpoint = void 0;\r\nconst argSerializer_1 = require(\"../argSerializer\");\r\nconst function_1 = require(\"../function\");\r\nconst nativeSerializer_1 = require(\"../nativeSerializer\");\r\n/**\r\n * Creates a FormattedCall from the given endpoint and args.\r\n */\r\nfunction formatEndpoint(executingEndpoint, interpretingEndpoint, ...args) {\r\n    return new FormattedCall(executingEndpoint, interpretingEndpoint, args);\r\n}\r\nexports.formatEndpoint = formatEndpoint;\r\n/**\r\n * Formats and validates the arguments of a bound call.\r\n * A bound call is represented by a function and its arguments packed together.\r\n * A function is defined as something that has an EndpointDefinition and may be:\r\n * - a smart contract method\r\n * - a built-in function (such as an ESDT transfer)\r\n */\r\nclass FormattedCall {\r\n    constructor(executingEndpoint, interpretingEndpoint, args) {\r\n        this.executingEndpoint = executingEndpoint;\r\n        this.interpretingEndpoint = interpretingEndpoint;\r\n        this.args = args;\r\n    }\r\n    getExecutingFunction() {\r\n        return new function_1.ContractFunction(this.executingEndpoint.name);\r\n    }\r\n    getInterpretingFunction() {\r\n        return new function_1.ContractFunction(this.interpretingEndpoint.name);\r\n    }\r\n    /**\r\n     * Takes the given arguments, and converts them to typed values, validating them against the given endpoint in the process.\r\n     */\r\n    toTypedValues() {\r\n        let expandedArgs = this.getExpandedArgs();\r\n        return nativeSerializer_1.NativeSerializer.nativeToTypedValues(expandedArgs, this.executingEndpoint);\r\n    }\r\n    toArgBuffers() {\r\n        let typedValues = this.toTypedValues();\r\n        return new argSerializer_1.ArgSerializer().valuesToBuffers(typedValues);\r\n    }\r\n    /**\r\n     * Formats the function name and its arguments as an array of buffers.\r\n     * This is useful for nested calls (for the multisig smart contract or for ESDT transfers).\r\n     * A formatted deploy call does not return the function name.\r\n     */\r\n    toCallBuffers() {\r\n        if (this.executingEndpoint.isConstructor()) {\r\n            return this.toArgBuffers();\r\n        }\r\n        return [Buffer.from(this.executingEndpoint.name), ...this.toArgBuffers()];\r\n    }\r\n    getExpandedArgs() {\r\n        let expanded = [];\r\n        for (let value of this.args) {\r\n            if (value instanceof FormattedCall) {\r\n                expanded = expanded.concat(value.toCallBuffers());\r\n            }\r\n            else {\r\n                expanded.push(value);\r\n            }\r\n        }\r\n        return expanded;\r\n    }\r\n}\r\nexports.FormattedCall = FormattedCall;\r\n//# sourceMappingURL=formattedCall.js.map"]},"metadata":{},"sourceType":"script"}