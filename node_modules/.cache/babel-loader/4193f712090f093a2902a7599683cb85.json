{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interaction = void 0;\n\nconst balance_1 = require(\"../balance\");\n\nconst networkParams_1 = require(\"../networkParams\");\n\nconst query_1 = require(\"./query\");\n\nconst address_1 = require(\"../address\");\n\nconst nonce_1 = require(\"../nonce\");\n/**\r\n * Interactions can be seen as mutable transaction & query builders.\r\n *\r\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\r\n * the execution outcome for the objects they've built.\r\n */\n\n\nclass Interaction {\n  constructor(contract, executingFunction, interpretingFunction, args, receiver) {\n    this.nonce = new nonce_1.Nonce(0);\n    this.value = balance_1.Balance.Zero();\n    this.gasLimit = networkParams_1.GasLimit.min();\n    this.contract = contract;\n    this.executingFunction = executingFunction;\n    this.interpretingFunction = interpretingFunction;\n    this.args = args;\n    this.receiver = receiver;\n  }\n\n  getContract() {\n    return this.contract;\n  }\n\n  getInterpretingFunction() {\n    return this.interpretingFunction;\n  }\n\n  getExecutingFunction() {\n    return this.executingFunction;\n  }\n\n  getArguments() {\n    return this.args;\n  }\n\n  getValue() {\n    return this.value;\n  }\n\n  getGasLimit() {\n    return this.gasLimit;\n  }\n\n  buildTransaction() {\n    // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\n    let transaction = this.contract.call({\n      func: this.executingFunction,\n      // GasLimit will be set using \"withGasLimit()\".\n      gasLimit: this.gasLimit,\n      args: this.args,\n      // Value will be set using \"withValue()\".\n      value: this.value,\n      receiver: this.receiver\n    });\n    transaction.setNonce(this.nonce);\n    return transaction;\n  }\n\n  buildQuery() {\n    return new query_1.Query({\n      address: this.contract.getAddress(),\n      func: this.executingFunction,\n      args: this.args,\n      // Value will be set using \"withValue()\".\n      value: this.value,\n      // Caller will be set by the InteractionRunner.\n      caller: new address_1.Address()\n    });\n  }\n  /**\r\n   * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\r\n   * The outcome is structured such that it allows quick access to each level of detail.\r\n   */\n\n\n  interpretExecutionResults(transactionOnNetwork) {\n    return interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\n  }\n  /**\r\n   * Interprets the raw outcome of a Smart Contract query.\r\n   * The outcome is structured such that it allows quick access to each level of detail.\r\n   */\n\n\n  interpretQueryResponse(queryResponse) {\n    let endpoint = this.getEndpoint();\n    queryResponse.setEndpointDefinition(endpoint);\n    let values = queryResponse.outputTyped();\n    let returnCode = queryResponse.returnCode;\n    return {\n      queryResponse: queryResponse,\n      values: values,\n      firstValue: values[0],\n      returnCode: returnCode\n    };\n  }\n\n  withValue(value) {\n    this.value = value;\n    return this;\n  }\n\n  withGasLimit(gasLimit) {\n    this.gasLimit = gasLimit;\n    return this;\n  }\n\n  withNonce(nonce) {\n    this.nonce = nonce;\n    return this;\n  }\n\n  getEndpoint() {\n    return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\n  }\n\n}\n\nexports.Interaction = Interaction;\n\nfunction interpretExecutionResults(endpoint, transactionOnNetwork) {\n  let smartContractResults = transactionOnNetwork.getSmartContractResults();\n  let immediateResult = smartContractResults.getImmediate();\n  let resultingCalls = smartContractResults.getResultingCalls();\n  immediateResult.setEndpointDefinition(endpoint);\n  let values = immediateResult.outputTyped();\n  let returnCode = immediateResult.getReturnCode();\n  return {\n    transactionOnNetwork: transactionOnNetwork,\n    smartContractResults: smartContractResults,\n    immediateResult,\n    resultingCalls,\n    values,\n    firstValue: values[0],\n    returnCode: returnCode\n  };\n}","map":{"version":3,"sources":["../../src/smartcontracts/interaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Interaction = void 0;\r\nconst balance_1 = require(\"../balance\");\r\nconst networkParams_1 = require(\"../networkParams\");\r\nconst query_1 = require(\"./query\");\r\nconst address_1 = require(\"../address\");\r\nconst nonce_1 = require(\"../nonce\");\r\n/**\r\n * Interactions can be seen as mutable transaction & query builders.\r\n *\r\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\r\n * the execution outcome for the objects they've built.\r\n */\r\nclass Interaction {\r\n    constructor(contract, executingFunction, interpretingFunction, args, receiver) {\r\n        this.nonce = new nonce_1.Nonce(0);\r\n        this.value = balance_1.Balance.Zero();\r\n        this.gasLimit = networkParams_1.GasLimit.min();\r\n        this.contract = contract;\r\n        this.executingFunction = executingFunction;\r\n        this.interpretingFunction = interpretingFunction;\r\n        this.args = args;\r\n        this.receiver = receiver;\r\n    }\r\n    getContract() {\r\n        return this.contract;\r\n    }\r\n    getInterpretingFunction() {\r\n        return this.interpretingFunction;\r\n    }\r\n    getExecutingFunction() {\r\n        return this.executingFunction;\r\n    }\r\n    getArguments() {\r\n        return this.args;\r\n    }\r\n    getValue() {\r\n        return this.value;\r\n    }\r\n    getGasLimit() {\r\n        return this.gasLimit;\r\n    }\r\n    buildTransaction() {\r\n        // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\r\n        let transaction = this.contract.call({\r\n            func: this.executingFunction,\r\n            // GasLimit will be set using \"withGasLimit()\".\r\n            gasLimit: this.gasLimit,\r\n            args: this.args,\r\n            // Value will be set using \"withValue()\".\r\n            value: this.value,\r\n            receiver: this.receiver,\r\n        });\r\n        transaction.setNonce(this.nonce);\r\n        return transaction;\r\n    }\r\n    buildQuery() {\r\n        return new query_1.Query({\r\n            address: this.contract.getAddress(),\r\n            func: this.executingFunction,\r\n            args: this.args,\r\n            // Value will be set using \"withValue()\".\r\n            value: this.value,\r\n            // Caller will be set by the InteractionRunner.\r\n            caller: new address_1.Address()\r\n        });\r\n    }\r\n    /**\r\n     * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\r\n     * The outcome is structured such that it allows quick access to each level of detail.\r\n     */\r\n    interpretExecutionResults(transactionOnNetwork) {\r\n        return interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\r\n    }\r\n    /**\r\n     * Interprets the raw outcome of a Smart Contract query.\r\n     * The outcome is structured such that it allows quick access to each level of detail.\r\n     */\r\n    interpretQueryResponse(queryResponse) {\r\n        let endpoint = this.getEndpoint();\r\n        queryResponse.setEndpointDefinition(endpoint);\r\n        let values = queryResponse.outputTyped();\r\n        let returnCode = queryResponse.returnCode;\r\n        return {\r\n            queryResponse: queryResponse,\r\n            values: values,\r\n            firstValue: values[0],\r\n            returnCode: returnCode\r\n        };\r\n    }\r\n    withValue(value) {\r\n        this.value = value;\r\n        return this;\r\n    }\r\n    withGasLimit(gasLimit) {\r\n        this.gasLimit = gasLimit;\r\n        return this;\r\n    }\r\n    withNonce(nonce) {\r\n        this.nonce = nonce;\r\n        return this;\r\n    }\r\n    getEndpoint() {\r\n        return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\r\n    }\r\n}\r\nexports.Interaction = Interaction;\r\nfunction interpretExecutionResults(endpoint, transactionOnNetwork) {\r\n    let smartContractResults = transactionOnNetwork.getSmartContractResults();\r\n    let immediateResult = smartContractResults.getImmediate();\r\n    let resultingCalls = smartContractResults.getResultingCalls();\r\n    immediateResult.setEndpointDefinition(endpoint);\r\n    let values = immediateResult.outputTyped();\r\n    let returnCode = immediateResult.getReturnCode();\r\n    return {\r\n        transactionOnNetwork: transactionOnNetwork,\r\n        smartContractResults: smartContractResults,\r\n        immediateResult,\r\n        resultingCalls,\r\n        values,\r\n        firstValue: values[0],\r\n        returnCode: returnCode\r\n    };\r\n}\r\n//# sourceMappingURL=interaction.js.map"]},"metadata":{},"sourceType":"script"}