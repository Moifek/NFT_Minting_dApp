{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultInteractionRunner = void 0;\n/**\r\n * An interaction runner suitable for backends or wallets.\r\n * Not suitable for dapps, which depend on external signers (wallets, ledger etc.).\r\n */\n\nclass DefaultInteractionRunner {\n  constructor(checker, signer, provider) {\n    this.checker = checker;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\r\n   * Given an interaction, broadcasts its compiled transaction.\r\n   */\n\n\n  run(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = interaction.buildTransaction();\n      yield this.signer.sign(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n  /**\r\n   * Given an interaction, broadcasts its compiled transaction (and also waits for its execution on the Network).\r\n   */\n\n\n  runAwaitExecution(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = yield this.run(interaction);\n      yield transaction.awaitExecuted(this.provider); // This will wait until the transaction is notarized, as well (so that SCRs are returned by the API).\n\n      let transactionOnNetwork = yield transaction.getAsOnNetwork(this.provider);\n      let bundle = interaction.interpretExecutionResults(transactionOnNetwork);\n      return bundle;\n    });\n  }\n\n  runQuery(interaction, caller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let query = interaction.buildQuery();\n      query.caller = caller || this.signer.getAddress();\n      let response = yield this.provider.queryContract(query);\n      let bundle = interaction.interpretQueryResponse(response);\n      return bundle;\n    });\n  }\n\n  runSimulation(interaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.checkInteraction(interaction);\n      let transaction = interaction.buildTransaction();\n      yield this.signer.sign(transaction);\n      return yield transaction.simulate(this.provider);\n    });\n  }\n\n  checkInteraction(interaction) {\n    this.checker.checkInteraction(interaction);\n  }\n\n}\n\nexports.DefaultInteractionRunner = DefaultInteractionRunner;","map":{"version":3,"sources":["../../src/smartcontracts/defaultRunner.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;AAGG;;AACH,MAAa,wBAAb,CAAqC;EAKjC,WAAA,CAAY,OAAZ,EAA0C,MAA1C,EAA2D,QAA3D,EAA8E;IAC1E,KAAK,OAAL,GAAe,OAAf;IACA,KAAK,MAAL,GAAc,MAAd;IACA,KAAK,QAAL,GAAgB,QAAhB;EACH;EAED;;AAEG;;;EACG,GAAG,CAAC,WAAD,EAAyB;;MAC9B,KAAK,gBAAL,CAAsB,WAAtB;MAEA,IAAI,WAAW,GAAG,WAAW,CAAC,gBAAZ,EAAlB;MACA,MAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAjB,CAAN;MACA,MAAM,WAAW,CAAC,IAAZ,CAAiB,KAAK,QAAtB,CAAN;MACA,OAAO,WAAP;IACH,C;EAAA;EAED;;AAEG;;;EACG,iBAAiB,CAAC,WAAD,EAAyB;;MAC5C,KAAK,gBAAL,CAAsB,WAAtB;MAEA,IAAI,WAAW,GAAG,MAAM,KAAK,GAAL,CAAS,WAAT,CAAxB;MACA,MAAM,WAAW,CAAC,aAAZ,CAA0B,KAAK,QAA/B,CAAN,C,CACA;;MACA,IAAI,oBAAoB,GAAG,MAAM,WAAW,CAAC,cAAZ,CAA2B,KAAK,QAAhC,CAAjC;MACA,IAAI,MAAM,GAAG,WAAW,CAAC,yBAAZ,CAAsC,oBAAtC,CAAb;MACA,OAAO,MAAP;IACH,C;EAAA;;EAEK,QAAQ,CAAC,WAAD,EAA2B,MAA3B,EAA2C;;MACrD,KAAK,gBAAL,CAAsB,WAAtB;MAEA,IAAI,KAAK,GAAG,WAAW,CAAC,UAAZ,EAAZ;MACA,KAAK,CAAC,MAAN,GAAe,MAAM,IAAI,KAAK,MAAL,CAAY,UAAZ,EAAzB;MACA,IAAI,QAAQ,GAAG,MAAM,KAAK,QAAL,CAAc,aAAd,CAA4B,KAA5B,CAArB;MACA,IAAI,MAAM,GAAG,WAAW,CAAC,sBAAZ,CAAmC,QAAnC,CAAb;MACA,OAAO,MAAP;IACH,C;EAAA;;EAEK,aAAa,CAAC,WAAD,EAAyB;;MACxC,KAAK,gBAAL,CAAsB,WAAtB;MAEA,IAAI,WAAW,GAAG,WAAW,CAAC,gBAAZ,EAAlB;MACA,MAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,WAAjB,CAAN;MACA,OAAO,MAAM,WAAW,CAAC,QAAZ,CAAqB,KAAK,QAA1B,CAAb;IACH,C;EAAA;;EAEO,gBAAgB,CAAC,WAAD,EAAyB;IAC7C,KAAK,OAAL,CAAa,gBAAb,CAA8B,WAA9B;EACH;;AAzDgC;;AAArC,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DefaultInteractionRunner = void 0;\r\n/**\r\n * An interaction runner suitable for backends or wallets.\r\n * Not suitable for dapps, which depend on external signers (wallets, ledger etc.).\r\n */\r\nclass DefaultInteractionRunner {\r\n    constructor(checker, signer, provider) {\r\n        this.checker = checker;\r\n        this.signer = signer;\r\n        this.provider = provider;\r\n    }\r\n    /**\r\n     * Given an interaction, broadcasts its compiled transaction.\r\n     */\r\n    run(interaction) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.checkInteraction(interaction);\r\n            let transaction = interaction.buildTransaction();\r\n            yield this.signer.sign(transaction);\r\n            yield transaction.send(this.provider);\r\n            return transaction;\r\n        });\r\n    }\r\n    /**\r\n     * Given an interaction, broadcasts its compiled transaction (and also waits for its execution on the Network).\r\n     */\r\n    runAwaitExecution(interaction) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.checkInteraction(interaction);\r\n            let transaction = yield this.run(interaction);\r\n            yield transaction.awaitExecuted(this.provider);\r\n            // This will wait until the transaction is notarized, as well (so that SCRs are returned by the API).\r\n            let transactionOnNetwork = yield transaction.getAsOnNetwork(this.provider);\r\n            let bundle = interaction.interpretExecutionResults(transactionOnNetwork);\r\n            return bundle;\r\n        });\r\n    }\r\n    runQuery(interaction, caller) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.checkInteraction(interaction);\r\n            let query = interaction.buildQuery();\r\n            query.caller = caller || this.signer.getAddress();\r\n            let response = yield this.provider.queryContract(query);\r\n            let bundle = interaction.interpretQueryResponse(response);\r\n            return bundle;\r\n        });\r\n    }\r\n    runSimulation(interaction) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.checkInteraction(interaction);\r\n            let transaction = interaction.buildTransaction();\r\n            yield this.signer.sign(transaction);\r\n            return yield transaction.simulate(this.provider);\r\n        });\r\n    }\r\n    checkInteraction(interaction) {\r\n        this.checker.checkInteraction(interaction);\r\n    }\r\n}\r\nexports.DefaultInteractionRunner = DefaultInteractionRunner;\r\n//# sourceMappingURL=defaultRunner.js.map"]},"metadata":{},"sourceType":"script"}