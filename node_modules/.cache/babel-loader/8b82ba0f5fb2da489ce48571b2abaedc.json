{"ast":null,"code":"import { SmartContract, Account, parseUserKey, UserSigner, GasLimit, Address, ContractFunction } from \"@elrondnetwork/erdjs\"; //import { Provider } from \"react\";\n\nimport data from \"./wallet.json\";\nlet LoggedUseraddress = \"\";\nexport const getMintTransaction = (contractAddress, baseGasLimit, tokensAmount) => {\n  const tokens = tokensAmount || 1;\n  const tokenSellingPrice = \"500000000000000000\";\n  const contract = new SmartContract({\n    address: new Address(contractAddress)\n  });\n  return contract.call({\n    func: new ContractFunction(\"getNftPrice\"),\n    gasLimit: new GasLimit(baseGasLimit + baseGasLimit / 1.4 * (tokensAmount - 1)) //args: [new U32Value(tokens)],\n    //value: Balance.fromString(tokenSellingPrice).times(tokens),\n\n  });\n};\nexport const commonTxOperations = async (tx, account, signer, provider) => {\n  tx.setNonce(account.nonce);\n  account.incrementNonce();\n  signer.sign(tx);\n  await tx.send(provider);\n  await tx.awaitExecuted(provider);\n  const txHash = tx.getHash();\n  console.log(`Transaction: /transactions/${txHash}`);\n};\nexport const GetAddress = async LoggedUserAddress => {\n  LoggedUseraddress = LoggedUserAddress;\n};\n_c = GetAddress;\nexport const prepareUserAccount = async walletPemKey => {\n  const userKey = parseUserKey(walletPemKey);\n  const address = userKey.generatePublicKey().toAddress();\n  return new Account(address);\n};\nexport const publicEndpointSetup = async provider => {\n  let keyFileObject = JSON.parse(JSON.stringify(data)); // Provider type based on initial configuration\n\n  let LoggedUserAddress = new Address(LoggedUseraddress);\n  let LoggedUserAccount = new Account(LoggedUserAddress);\n  let syncc = await LoggedUserAccount.sync(provider);\n  console.log(syncc);\n  const signer = UserSigner.fromWallet(keyFileObject, \"u!D?G8Tf48fYL28\");\n  return {\n    signer,\n    LoggedUserAccount,\n    provider\n  };\n};\nexport const parseQueryResultString = queryResponse => {\n  var _queryResponse$return;\n\n  const resultBuff = Buffer.from(queryResponse === null || queryResponse === void 0 ? void 0 : (_queryResponse$return = queryResponse.returnData) === null || _queryResponse$return === void 0 ? void 0 : _queryResponse$return[0], 'base64').toString('utf8');\n  return resultBuff;\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"GetAddress\");","map":{"version":3,"sources":["/home/mmo/workspace/NFT_Minting_dApp/src/pages/Home/utils.ts"],"names":["SmartContract","Account","parseUserKey","UserSigner","GasLimit","Address","ContractFunction","data","LoggedUseraddress","getMintTransaction","contractAddress","baseGasLimit","tokensAmount","tokens","tokenSellingPrice","contract","address","call","func","gasLimit","commonTxOperations","tx","account","signer","provider","setNonce","nonce","incrementNonce","sign","send","awaitExecuted","txHash","getHash","console","log","GetAddress","LoggedUserAddress","prepareUserAccount","walletPemKey","userKey","generatePublicKey","toAddress","publicEndpointSetup","keyFileObject","JSON","parse","stringify","LoggedUserAccount","syncc","sync","fromWallet","parseQueryResultString","queryResponse","resultBuff","Buffer","from","returnData","toString"],"mappings":"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","sourcesContent":["import {\n  ProxyProvider,\n  SmartContract,\n  Account,\n  parseUserKey,\n  UserSigner,\n  GasLimit,\n  Address,\n  ContractFunction,\n  Balance,\n  U32Value,\n  Transaction,\n  ISigner,\n  QueryResponse,\n} from \"@elrondnetwork/erdjs\";\n//import { Provider } from \"react\";\nimport data from \"./wallet.json\";\n\nlet LoggedUseraddress = \"\";\n\nexport const getMintTransaction = (\n  contractAddress: string,\n  baseGasLimit: number,\n  tokensAmount: number\n) => {\n  const tokens = tokensAmount || 1;\n  const tokenSellingPrice = \"500000000000000000\";\n  const contract = new SmartContract({\n    address: new Address(contractAddress),\n  });\n  return contract.call({\n    func: new ContractFunction(\"getNftPrice\"),\n    gasLimit: new GasLimit(\n      baseGasLimit + (baseGasLimit / 1.4) * (tokensAmount - 1)\n    ),\n    //args: [new U32Value(tokens)],\n    //value: Balance.fromString(tokenSellingPrice).times(tokens),\n  });\n};\n\nexport const commonTxOperations = async (\n  tx: Transaction,\n  account: Account,\n  signer: ISigner,\n  provider: ProxyProvider\n) => {\n  tx.setNonce(account.nonce);\n  account.incrementNonce();\n  signer.sign(tx);\n\n  await tx.send(provider);\n  await tx.awaitExecuted(provider);\n  const txHash = tx.getHash();\n\n  console.log(`Transaction: /transactions/${txHash}`);\n};\n\nexport const GetAddress = async (LoggedUserAddress: string) => {\n  LoggedUseraddress = LoggedUserAddress;\n};\nexport const prepareUserAccount = async (walletPemKey: string) => {\n  const userKey = parseUserKey(walletPemKey);\n  const address = userKey.generatePublicKey().toAddress();\n  return new Account(address);\n};\n\nexport const publicEndpointSetup = async (provider: ProxyProvider) => {\n  let keyFileObject = JSON.parse(JSON.stringify(data));\n  // Provider type based on initial configuration\n  let LoggedUserAddress = new Address(LoggedUseraddress);\n  let LoggedUserAccount = new Account(LoggedUserAddress);\n  let syncc = await LoggedUserAccount.sync(provider);\n  console.log(syncc);\n  const signer = UserSigner.fromWallet(keyFileObject, \"u!D?G8Tf48fYL28\");\n  return {\n    signer,\n    LoggedUserAccount,\n    provider,\n  };\n};\n\nexport const parseQueryResultString = (queryResponse: QueryResponse) => {\n  const resultBuff = Buffer.from(\n    queryResponse?.returnData?.[0],\n    'base64'\n  ).toString('utf8');\n  return resultBuff;\n};"]},"metadata":{},"sourceType":"module"}