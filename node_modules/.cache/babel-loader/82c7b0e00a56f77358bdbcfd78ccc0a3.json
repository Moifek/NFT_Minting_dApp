{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroPadStringIfOddLength = exports.isPaddedHex = exports.numberToPaddedHex = exports.Nonce = exports.Address = void 0;\n\nconst bech32 = __importStar(require(\"bech32\"));\n/**\n * The human-readable-part of the bech32 addresses.\n */\n\n\nconst HRP = \"erd\";\n\nclass Address {\n  constructor(value) {\n    this.value = value;\n  }\n\n  static fromPubkey(pubkey) {\n    let words = bech32.toWords(pubkey);\n    let address = bech32.encode(HRP, words);\n    return new Address(address);\n  }\n\n  bech32() {\n    return this.value;\n  }\n\n}\n\nexports.Address = Address;\n\nclass Nonce {\n  constructor(value) {\n    this.value = value;\n  }\n\n  valueOf() {\n    return this.value;\n  }\n\n  hex() {\n    return numberToPaddedHex(this.value);\n  }\n\n}\n\nexports.Nonce = Nonce;\n\nfunction numberToPaddedHex(value) {\n  let hex = value.toString(16);\n  return zeroPadStringIfOddLength(hex);\n}\n\nexports.numberToPaddedHex = numberToPaddedHex;\n\nfunction isPaddedHex(input) {\n  input = input || \"\";\n  let decodedThenEncoded = Buffer.from(input, \"hex\").toString(\"hex\");\n  return input.toUpperCase() == decodedThenEncoded.toUpperCase();\n}\n\nexports.isPaddedHex = isPaddedHex;\n\nfunction zeroPadStringIfOddLength(input) {\n  input = input || \"\";\n\n  if (input.length % 2 == 1) {\n    return \"0\" + input;\n  }\n\n  return input;\n}\n\nexports.zeroPadStringIfOddLength = zeroPadStringIfOddLength;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;;;;;AAGA,MAAMA,GAAG,GAAG,KAAZ;;AAEA,MAAaC,OAAb,CAAoB;AAGhBC,cAAYC,KAAZ,EAAyB;AACrB,SAAKA,KAAL,GAAaA,KAAb;AACH;;AAEgB,SAAVC,UAAU,CAACC,MAAD,EAAe;AAC5B,QAAIC,KAAK,GAAGC,MAAM,CAACC,OAAP,CAAeH,MAAf,CAAZ;AACA,QAAII,OAAO,GAAGF,MAAM,CAACG,MAAP,CAAcV,GAAd,EAAmBM,KAAnB,CAAd;AACA,WAAO,IAAIL,OAAJ,CAAYQ,OAAZ,CAAP;AACH;;AAEDF,QAAM;AACF,WAAO,KAAKJ,KAAZ;AACH;;AAfe;;AAApBQ;;AAkBA,MAAaC,KAAb,CAAkB;AAGdV,cAAYC,KAAZ,EAAyB;AACrB,SAAKA,KAAL,GAAaA,KAAb;AACH;;AAEDU,SAAO;AACH,WAAO,KAAKV,KAAZ;AACH;;AAEDW,KAAG;AACC,WAAOC,iBAAiB,CAAC,KAAKZ,KAAN,CAAxB;AACH;;AAba;;AAAlBQ;;AAgBA,SAAgBI,iBAAhB,CAAkCZ,KAAlC,EAA+C;AAC3C,MAAIW,GAAG,GAAGX,KAAK,CAACa,QAAN,CAAe,EAAf,CAAV;AACA,SAAOC,wBAAwB,CAACH,GAAD,CAA/B;AACH;;AAHDH;;AAKA,SAAgBO,WAAhB,CAA4BC,KAA5B,EAAyC;AACrCA,OAAK,GAAGA,KAAK,IAAI,EAAjB;AACA,MAAIC,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYH,KAAZ,EAAmB,KAAnB,EAA0BH,QAA1B,CAAmC,KAAnC,CAAzB;AACA,SAAOG,KAAK,CAACI,WAAN,MAAuBH,kBAAkB,CAACG,WAAnB,EAA9B;AACH;;AAJDZ;;AAMA,SAAgBM,wBAAhB,CAAyCE,KAAzC,EAAsD;AAClDA,OAAK,GAAGA,KAAK,IAAI,EAAjB;;AAEA,MAAIA,KAAK,CAACK,MAAN,GAAe,CAAf,IAAoB,CAAxB,EAA2B;AACvB,WAAO,MAAML,KAAb;AACH;;AAED,SAAOA,KAAP;AACH;;AARDR","names":["HRP","Address","constructor","value","fromPubkey","pubkey","words","bech32","toWords","address","encode","exports","Nonce","valueOf","hex","numberToPaddedHex","toString","zeroPadStringIfOddLength","isPaddedHex","input","decodedThenEncoded","Buffer","from","toUpperCase","length"],"sourceRoot":"","sources":["../src/primitives.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}