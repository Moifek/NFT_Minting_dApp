{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst collections_1 = require(\"./collections\");\n\nconst types_1 = require(\"./types\"); // TODO: Move to a new file, \"genericOption.ts\"\n\n\nclass OptionType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Option\", [typeParameter]);\n  }\n\n  getClassName() {\n    return OptionType.ClassName;\n  }\n\n  isAssignableFrom(type) {\n    if (!type.hasExactClass(OptionType.ClassName)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\"; // TODO: Move to a new file, \"genericList.ts\"\n\nclass ListType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"List\", [typeParameter]);\n  }\n\n  getClassName() {\n    return ListType.ClassName;\n  }\n\n}\n\nexports.ListType = ListType;\nListType.ClassName = \"ListType\"; // TODO: Move to a new file, \"genericOption.ts\"\n\nclass OptionValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n\n  getClassName() {\n    return OptionValue.ClassName;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  static newMissing() {\n    let type = new OptionType(new types_1.NullType());\n    return new OptionValue(type);\n  }\n\n  static newMissingType(type) {\n    return new OptionValue(new OptionType(type));\n  }\n  /**\n   * Creates an OptionValue, as a provided option argument.\n   */\n\n\n  static newProvided(typedValue) {\n    let type = new OptionType(typedValue.getType());\n    return new OptionValue(type, typedValue);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\"; // TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nclass List extends types_1.TypedValue {\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  constructor(type, items) {\n    super(type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n  }\n\n  getClassName() {\n    return List.ClassName;\n  }\n\n  static fromItems(items) {\n    if (items.length == 0) {\n      return new List(new types_1.TypePlaceholder(), []);\n    }\n\n    let typeParameter = items[0].getType();\n    let listType = new ListType(typeParameter);\n    return new List(listType, items);\n  }\n\n  getLength() {\n    return this.backingCollection.getLength();\n  }\n\n  getItems() {\n    return this.backingCollection.getItems();\n  }\n\n  valueOf() {\n    return this.backingCollection.valueOf();\n  }\n\n  equals(other) {\n    return this.backingCollection.equals(other.backingCollection);\n  }\n\n}\n\nexports.List = List;\nList.ClassName = \"List\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/generic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nconst utils_1 = require(\"../../utils\");\nconst collections_1 = require(\"./collections\");\nconst types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"Option\", [typeParameter]);\n    }\n    getClassName() {\n        return OptionType.ClassName;\n    }\n    isAssignableFrom(type) {\n        if (!(type.hasExactClass(OptionType.ClassName))) {\n            return false;\n        }\n        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n        let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n        return invariantTypeParameters || fakeCovarianceToNull;\n    }\n}\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\";\n// TODO: Move to a new file, \"genericList.ts\"\nclass ListType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"List\", [typeParameter]);\n    }\n    getClassName() {\n        return ListType.ClassName;\n    }\n}\nexports.ListType = ListType;\nListType.ClassName = \"ListType\";\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionValue extends types_1.TypedValue {\n    constructor(type, value = null) {\n        super(type);\n        // TODO: assert value is of type type.getFirstTypeParameter()\n        this.value = value;\n    }\n    getClassName() {\n        return OptionValue.ClassName;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n    static newMissing() {\n        let type = new OptionType(new types_1.NullType());\n        return new OptionValue(type);\n    }\n    static newMissingType(type) {\n        return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n    static newProvided(typedValue) {\n        let type = new OptionType(typedValue.getType());\n        return new OptionValue(type, typedValue);\n    }\n    isSet() {\n        return this.value ? true : false;\n    }\n    getTypedValue() {\n        utils_1.guardValueIsSet(\"value\", this.value);\n        return this.value;\n    }\n    valueOf() {\n        return this.value ? this.value.valueOf() : null;\n    }\n    equals(other) {\n        var _a;\n        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n}\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\";\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nclass List extends types_1.TypedValue {\n    /**\n     *\n     * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n     * @param items the items, having the type type.getFirstTypeParameter()\n     */\n    constructor(type, items) {\n        super(type);\n        // TODO: assert items are of type type.getFirstTypeParameter()\n        this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    }\n    getClassName() {\n        return List.ClassName;\n    }\n    static fromItems(items) {\n        if (items.length == 0) {\n            return new List(new types_1.TypePlaceholder(), []);\n        }\n        let typeParameter = items[0].getType();\n        let listType = new ListType(typeParameter);\n        return new List(listType, items);\n    }\n    getLength() {\n        return this.backingCollection.getLength();\n    }\n    getItems() {\n        return this.backingCollection.getItems();\n    }\n    valueOf() {\n        return this.backingCollection.valueOf();\n    }\n    equals(other) {\n        return this.backingCollection.equals(other.backingCollection);\n    }\n}\nexports.List = List;\nList.ClassName = \"List\";\n//# sourceMappingURL=generic.js.map"]},"metadata":{},"sourceType":"script"}