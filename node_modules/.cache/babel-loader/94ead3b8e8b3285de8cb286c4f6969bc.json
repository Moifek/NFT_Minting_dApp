{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletProvider = void 0;\n\nconst qs_1 = __importDefault(require(\"qs\"));\n\nconst constants_1 = require(\"./constants\");\n\nconst transaction_1 = require(\"../transaction\");\n\nconst errors_1 = require(\"../errors\");\n\nconst signature_1 = require(\"../signature\");\n\nconst nonce_1 = require(\"../nonce\");\n\nconst balance_1 = require(\"../balance\");\n\nconst address_1 = require(\"../address\");\n\nconst networkParams_1 = require(\"../networkParams\");\n\nconst transactionPayload_1 = require(\"../transactionPayload\");\n\nclass WalletProvider {\n  /**\r\n   * Creates a new WalletProvider\r\n   * @param walletURL\r\n   */\n  constructor() {\n    let walletURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    this.walletUrl = walletURL;\n  }\n  /**\r\n   * Waits for the wallet iframe to ping that it has been initialised\r\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  }\n  /**\r\n   * Returns if the wallet iframe is up and running\r\n   */\n\n\n  isInitialized() {\n    return true;\n  }\n  /**\r\n   * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\r\n   *  and has the wallet session active\r\n   */\n\n\n  isConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return false;\n    });\n  }\n  /**\r\n   * Fetches the login hook url and redirects the client to the wallet login.\r\n   */\n\n\n  login(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let callbackUrl = `callbackUrl=${window.location.href}`;\n\n      if (options && options.callbackUrl) {\n        callbackUrl = `callbackUrl=${options.callbackUrl}`;\n      }\n\n      let token = '';\n\n      if (options && options.token) {\n        token = `&token=${options.token}`;\n      }\n\n      const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_CONNECT_URL}?${callbackUrl}${token}`;\n      yield new Promise(resolve => {\n        setTimeout(() => {\n          window.location.href = redirect;\n          resolve(true);\n        }, 10);\n      });\n      return window.location.href;\n    });\n  }\n  /**\r\n  * Fetches the logout hook url and redirects the client to the wallet logout.\r\n  */\n\n\n  logout(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let callbackUrl = `callbackUrl=${window.location.href}`;\n\n      if (options && options.callbackUrl) {\n        callbackUrl = `callbackUrl=${options.callbackUrl}`;\n      }\n\n      const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_DISCONNECT_URL}?${callbackUrl}`;\n      yield new Promise(resolve => {\n        setTimeout(() => {\n          window.location.href = redirect;\n          resolve(true);\n        }, 10);\n      });\n      return true;\n    });\n  }\n  /**\r\n   * Returns currently connected address. Empty string if not connected\r\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n  /**\r\n   * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\r\n   *   the client to the send transaction hook\r\n   * @param transaction\r\n   * @param options\r\n   */\n\n\n  sendTransaction(transaction, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transaction;\n    });\n  }\n  /**\r\n   * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\r\n   *\r\n   * @param transactions\r\n   * @param options\r\n   */\n\n\n  signTransactions(transactions, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonToSend = {};\n      transactions.map(tx => {\n        let plainTx = WalletProvider.prepareWalletTransaction(tx);\n\n        for (let txProp in plainTx) {\n          if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\n            jsonToSend[txProp] = [];\n          }\n\n          jsonToSend[txProp].push(plainTx[txProp]);\n        }\n      });\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${qs_1.default.stringify(jsonToSend)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transactions;\n    });\n  }\n  /**\r\n   * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\r\n   *   the client to the sign transaction hook\r\n   * @param transaction\r\n   * @param options\r\n   */\n\n\n  signTransaction(transaction, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transaction;\n    });\n  }\n\n  getTransactionsFromWalletUrl() {\n    const transactions = [];\n    const urlParams = qs_1.default.parse(window.location.search.slice(1));\n\n    if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\n      return transactions;\n    }\n\n    return WalletProvider.getTxSignReturnValue(urlParams);\n  }\n  /**\r\n   * Method will be available once the ElrondWallet hook will be implemented\r\n   * @param _\r\n   */\n\n\n  signMessage(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n\n  static isTxSignReturnSuccess(urlParams) {\n    return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\n  }\n\n  static getTxSignReturnValue(urlParams) {\n    // \"options\" property is optional (it isn't always received from the Web Wallet)\n    const expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\", \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\n\n    for (let txProp of expectedProps) {\n      if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\n        throw new errors_1.ErrInvalidTxSignReturnValue();\n      }\n    }\n\n    const expectedLength = urlParams[\"nonce\"].length;\n\n    for (let txProp of expectedProps) {\n      if (urlParams[txProp].length !== expectedLength) {\n        throw new errors_1.ErrInvalidTxSignReturnValue();\n      }\n    }\n\n    const transactions = [];\n\n    for (let i = 0; i < expectedLength; i++) {\n      let tx = new transaction_1.Transaction(Object.assign({\n        nonce: new nonce_1.Nonce(urlParams[\"nonce\"][i]),\n        value: balance_1.Balance.fromString(urlParams[\"value\"][i]),\n        receiver: address_1.Address.fromString(urlParams[\"receiver\"][i]),\n        gasPrice: new networkParams_1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])),\n        gasLimit: new networkParams_1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])),\n        data: new transactionPayload_1.TransactionPayload(urlParams[\"data\"][i]),\n        chainID: new networkParams_1.ChainID(urlParams[\"chainID\"][i]),\n        version: new networkParams_1.TransactionVersion(parseInt(urlParams[\"version\"][i]))\n      }, urlParams[\"options\"] && urlParams[\"options\"][i] ? {\n        options: new networkParams_1.TransactionOptions(parseInt(urlParams[\"options\"][i]))\n      } : {}));\n      tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), address_1.Address.fromString(urlParams[\"sender\"][i]));\n      transactions.push(tx);\n    }\n\n    return transactions;\n  }\n\n  static prepareWalletTransaction(transaction) {\n    let plainTransaction = transaction.toPlainObject(); // We adjust the fields, in order to make them compatible with what the wallet expected\n\n    plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\n    plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\n    plainTransaction[\"value\"] = transaction.getValue().toString();\n    plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\n    plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\n    return plainTransaction;\n  }\n\n  buildTransactionUrl(transaction) {\n    let urlString = `receiver=${transaction.receiver}&value=${transaction.value}`;\n\n    if (transaction.gasLimit) {\n      urlString += `&gasLimit=${transaction.gasLimit}`;\n    }\n\n    if (transaction.gasPrice) {\n      urlString += `&gasPrice=${transaction.gasPrice}`;\n    }\n\n    if (transaction.data) {\n      urlString += `&data=${transaction.data}`;\n    }\n\n    if (transaction.nonce || transaction.nonce === 0) {\n      urlString += `&nonce=${transaction.nonce}`;\n    }\n\n    return urlString;\n  }\n\n  baseWalletUrl() {\n    const pathArray = this.walletUrl.split('/');\n    const protocol = pathArray[0];\n    const host = pathArray[2];\n    return protocol + '//' + host;\n  }\n\n}\n\nexports.WalletProvider = WalletProvider;","map":{"version":3,"sources":["../../src/dapp/walletProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WalletProvider = void 0;\r\nconst qs_1 = __importDefault(require(\"qs\"));\r\nconst constants_1 = require(\"./constants\");\r\nconst transaction_1 = require(\"../transaction\");\r\nconst errors_1 = require(\"../errors\");\r\nconst signature_1 = require(\"../signature\");\r\nconst nonce_1 = require(\"../nonce\");\r\nconst balance_1 = require(\"../balance\");\r\nconst address_1 = require(\"../address\");\r\nconst networkParams_1 = require(\"../networkParams\");\r\nconst transactionPayload_1 = require(\"../transactionPayload\");\r\nclass WalletProvider {\r\n    /**\r\n     * Creates a new WalletProvider\r\n     * @param walletURL\r\n     */\r\n    constructor(walletURL = '') {\r\n        this.walletUrl = walletURL;\r\n    }\r\n    /**\r\n     * Waits for the wallet iframe to ping that it has been initialised\r\n     */\r\n    init() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return true;\r\n        });\r\n    }\r\n    /**\r\n     * Returns if the wallet iframe is up and running\r\n     */\r\n    isInitialized() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\r\n     *  and has the wallet session active\r\n     */\r\n    isConnected() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return false;\r\n        });\r\n    }\r\n    /**\r\n     * Fetches the login hook url and redirects the client to the wallet login.\r\n     */\r\n    login(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let callbackUrl = `callbackUrl=${window.location.href}`;\r\n            if (options && options.callbackUrl) {\r\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\r\n            }\r\n            let token = '';\r\n            if (options && options.token) {\r\n                token = `&token=${options.token}`;\r\n            }\r\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_CONNECT_URL}?${callbackUrl}${token}`;\r\n            yield new Promise((resolve) => {\r\n                setTimeout(() => {\r\n                    window.location.href = redirect;\r\n                    resolve(true);\r\n                }, 10);\r\n            });\r\n            return window.location.href;\r\n        });\r\n    }\r\n    /**\r\n    * Fetches the logout hook url and redirects the client to the wallet logout.\r\n    */\r\n    logout(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let callbackUrl = `callbackUrl=${window.location.href}`;\r\n            if (options && options.callbackUrl) {\r\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\r\n            }\r\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_DISCONNECT_URL}?${callbackUrl}`;\r\n            yield new Promise((resolve) => {\r\n                setTimeout(() => {\r\n                    window.location.href = redirect;\r\n                    resolve(true);\r\n                }, 10);\r\n            });\r\n            return true;\r\n        });\r\n    }\r\n    /**\r\n     * Returns currently connected address. Empty string if not connected\r\n     */\r\n    getAddress() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.ErrNotImplemented();\r\n        });\r\n    }\r\n    /**\r\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\r\n     *   the client to the send transaction hook\r\n     * @param transaction\r\n     * @param options\r\n     */\r\n    sendTransaction(transaction, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\r\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\r\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\r\n            return transaction;\r\n        });\r\n    }\r\n    /**\r\n     * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\r\n     *\r\n     * @param transactions\r\n     * @param options\r\n     */\r\n    signTransactions(transactions, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const jsonToSend = {};\r\n            transactions.map(tx => {\r\n                let plainTx = WalletProvider.prepareWalletTransaction(tx);\r\n                for (let txProp in plainTx) {\r\n                    if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\r\n                        jsonToSend[txProp] = [];\r\n                    }\r\n                    jsonToSend[txProp].push(plainTx[txProp]);\r\n                }\r\n            });\r\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${qs_1.default.stringify(jsonToSend)}`;\r\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\r\n            return transactions;\r\n        });\r\n    }\r\n    /**\r\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\r\n     *   the client to the sign transaction hook\r\n     * @param transaction\r\n     * @param options\r\n     */\r\n    signTransaction(transaction, options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\r\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\r\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\r\n            return transaction;\r\n        });\r\n    }\r\n    getTransactionsFromWalletUrl() {\r\n        const transactions = [];\r\n        const urlParams = qs_1.default.parse(window.location.search.slice(1));\r\n        if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\r\n            return transactions;\r\n        }\r\n        return WalletProvider.getTxSignReturnValue(urlParams);\r\n    }\r\n    /**\r\n     * Method will be available once the ElrondWallet hook will be implemented\r\n     * @param _\r\n     */\r\n    signMessage(_) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.ErrNotImplemented();\r\n        });\r\n    }\r\n    static isTxSignReturnSuccess(urlParams) {\r\n        return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\r\n    }\r\n    static getTxSignReturnValue(urlParams) {\r\n        // \"options\" property is optional (it isn't always received from the Web Wallet)\r\n        const expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\",\r\n            \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\r\n        for (let txProp of expectedProps) {\r\n            if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\r\n                throw new errors_1.ErrInvalidTxSignReturnValue();\r\n            }\r\n        }\r\n        const expectedLength = urlParams[\"nonce\"].length;\r\n        for (let txProp of expectedProps) {\r\n            if (urlParams[txProp].length !== expectedLength) {\r\n                throw new errors_1.ErrInvalidTxSignReturnValue();\r\n            }\r\n        }\r\n        const transactions = [];\r\n        for (let i = 0; i < expectedLength; i++) {\r\n            let tx = new transaction_1.Transaction(Object.assign({ nonce: new nonce_1.Nonce(urlParams[\"nonce\"][i]), value: balance_1.Balance.fromString(urlParams[\"value\"][i]), receiver: address_1.Address.fromString(urlParams[\"receiver\"][i]), gasPrice: new networkParams_1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])), gasLimit: new networkParams_1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])), data: new transactionPayload_1.TransactionPayload(urlParams[\"data\"][i]), chainID: new networkParams_1.ChainID(urlParams[\"chainID\"][i]), version: new networkParams_1.TransactionVersion(parseInt(urlParams[\"version\"][i])) }, (urlParams[\"options\"] && urlParams[\"options\"][i] ? {\r\n                options: new networkParams_1.TransactionOptions(parseInt(urlParams[\"options\"][i]))\r\n            } : {})));\r\n            tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), address_1.Address.fromString(urlParams[\"sender\"][i]));\r\n            transactions.push(tx);\r\n        }\r\n        return transactions;\r\n    }\r\n    static prepareWalletTransaction(transaction) {\r\n        let plainTransaction = transaction.toPlainObject();\r\n        // We adjust the fields, in order to make them compatible with what the wallet expected\r\n        plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\r\n        plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\r\n        plainTransaction[\"value\"] = transaction.getValue().toString();\r\n        plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\r\n        plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\r\n        return plainTransaction;\r\n    }\r\n    buildTransactionUrl(transaction) {\r\n        let urlString = `receiver=${transaction.receiver}&value=${transaction.value}`;\r\n        if (transaction.gasLimit) {\r\n            urlString += `&gasLimit=${transaction.gasLimit}`;\r\n        }\r\n        if (transaction.gasPrice) {\r\n            urlString += `&gasPrice=${transaction.gasPrice}`;\r\n        }\r\n        if (transaction.data) {\r\n            urlString += `&data=${transaction.data}`;\r\n        }\r\n        if (transaction.nonce || transaction.nonce === 0) {\r\n            urlString += `&nonce=${transaction.nonce}`;\r\n        }\r\n        return urlString;\r\n    }\r\n    baseWalletUrl() {\r\n        const pathArray = this.walletUrl.split('/');\r\n        const protocol = pathArray[0];\r\n        const host = pathArray[2];\r\n        return protocol + '//' + host;\r\n    }\r\n}\r\nexports.WalletProvider = WalletProvider;\r\n//# sourceMappingURL=walletProvider.js.map"]},"metadata":{},"sourceType":"script"}