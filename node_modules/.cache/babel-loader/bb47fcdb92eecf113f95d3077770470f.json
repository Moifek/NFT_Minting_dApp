{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\n\nconst reflection_1 = require(\"../../reflection\");\n\nconst utils_1 = require(\"../../utils\");\n/**\r\n * An abstraction that represents a Type. Handles both generic and non-generic types.\r\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\r\n */\n\n\nclass Type {\n  constructor(name) {\n    let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getClassName() {\n    return Type.ClassName;\n  }\n\n  getClassHierarchy() {\n    let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\n    let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\n    return classNames;\n  }\n  /**\r\n   * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within erdjs' typesystem.\r\n   */\n\n\n  getFullyQualifiedName() {\n    let joinedTypeParameters = this.getTypeParameters().map(type => type.getFullyQualifiedName()).join(\", \");\n    return this.isGenericType() ? `erdjs:types:${this.getName()}<${joinedTypeParameters}>` : `erdjs:types:${this.getName()}`;\n  }\n\n  hasExactClass(className) {\n    return this.getClassName() == className;\n  }\n\n  hasClassOrSuperclass(className) {\n    let hierarchy = this.getClassHierarchy();\n    return hierarchy.includes(className);\n  }\n\n  getTypeParameters() {\n    return this.typeParameters;\n  }\n\n  isGenericType() {\n    return this.typeParameters.length > 0;\n  }\n\n  getFirstTypeParameter() {\n    utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n    return this.typeParameters[0];\n  }\n  /**\r\n   * Generates type expressions similar to elrond-wasm-rs.\r\n   */\n\n\n  toString() {\n    let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n    let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n    return `${this.name}${typeParametersExpression}`;\n  }\n\n  equals(other) {\n    return Type.equals(this, other);\n  }\n\n  static equals(a, b) {\n    return a.getFullyQualifiedName() == b.getFullyQualifiedName();\n  }\n\n  static equalsMany(a, b) {\n    return a.every((type, i) => type.equals(b[i]));\n  }\n\n  static isAssignableFromMany(a, b) {\n    return a.every((type, i) => type.isAssignableFrom(b[i]));\n  }\n\n  differs(other) {\n    return !this.equals(other);\n  }\n\n  valueOf() {\n    return this.name;\n  }\n  /**\r\n   * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\r\n   * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\r\n   *\r\n   * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\r\n   * For example, Option<u32> is assignable from Option<?>.\r\n   * For more details, see the implementation of {@link OptionType}.\r\n   *\r\n   * Also see:\r\n   *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\r\n   *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\r\n   */\n\n\n  isAssignableFrom(other) {\n    let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());\n\n    if (!invariantTypeParameters) {\n      return false;\n    }\n\n    let fullyQualifiedNameOfThis = this.getFullyQualifiedName();\n    let fullyQualifiedNamesInHierarchyOfOther = Type.getFullyQualifiedNamesInHierarchy(other);\n\n    if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {\n      return true;\n    }\n\n    return other.hasClassOrSuperclass(this.getClassName());\n  }\n\n  static getFullyQualifiedNamesInHierarchy(type) {\n    let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, prototype => prototype.belongsToTypesystem);\n    let fullyQualifiedNames = prototypes.map(prototype => prototype.getFullyQualifiedName.call(type));\n    return fullyQualifiedNames;\n  }\n  /**\r\n   * Converts the account to a pretty, plain JavaScript object.\r\n   */\n\n\n  toJSON() {\n    return {\n      name: this.name,\n      typeParameters: this.typeParameters.map(item => item.toJSON())\n    };\n  }\n\n  getCardinality() {\n    return this.cardinality;\n  }\n  /**\r\n   * A special marker for types within erdjs' typesystem.\r\n   */\n\n\n  belongsToTypesystem() {}\n\n}\n\nexports.Type = Type;\nType.ClassName = \"Type\";\n/**\r\n * TODO: Simplify this class, keep only what is needed.\r\n *\r\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\r\n *\r\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\r\n * Composite types (not directly encodable) do not follow this constraint. For example:\r\n *  - VarArgs: [lower = 0, upper = *]\r\n *  - OptionalResult: [lower = 0, upper = 1]\r\n */\n\nclass TypeCardinality {\n  constructor(lowerBound, upperBound) {\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n\n  static fixed(value) {\n    return new TypeCardinality(value, value);\n  }\n\n  static variable(value) {\n    return new TypeCardinality(0, value);\n  }\n\n  isSingular() {\n    return this.lowerBound == 1 && this.upperBound == 1;\n  }\n\n  isSingularOrNone() {\n    return this.lowerBound == 0 && this.upperBound == 1;\n  }\n\n  isComposite() {\n    return this.upperBound != 1;\n  }\n\n  isFixed() {\n    return this.lowerBound == this.upperBound;\n  }\n\n  getLowerBound() {\n    return this.lowerBound;\n  }\n\n  getUpperBound() {\n    return this.upperBound || TypeCardinality.MaxCardinality;\n  }\n\n}\n\nexports.TypeCardinality = TypeCardinality;\n/**\r\n * An arbitrarily chosen, reasonably large number.\r\n */\n\nTypeCardinality.MaxCardinality = 4096;\n\nclass PrimitiveType extends Type {\n  constructor(name) {\n    super(name);\n  }\n\n  getClassName() {\n    return PrimitiveType.ClassName;\n  }\n\n}\n\nexports.PrimitiveType = PrimitiveType;\nPrimitiveType.ClassName = \"PrimitiveType\";\n\nclass CustomType extends Type {\n  getClassName() {\n    return CustomType.ClassName;\n  }\n\n}\n\nexports.CustomType = CustomType;\nCustomType.ClassName = \"CustomType\";\n\nclass TypedValue {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getClassName() {\n    return TypedValue.ClassName;\n  }\n\n  getClassHierarchy() {\n    let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\n    let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\n    return classNames;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  hasExactClass(className) {\n    return this.getClassName() == className;\n  }\n\n  hasClassOrSuperclass(className) {\n    let hierarchy = this.getClassHierarchy();\n    return hierarchy.includes(className);\n  }\n  /**\r\n   * A special marker for values within erdjs' typesystem.\r\n   */\n\n\n  belongsToTypesystem() {}\n\n}\n\nexports.TypedValue = TypedValue;\nTypedValue.ClassName = \"TypedValue\";\n\nclass PrimitiveValue extends TypedValue {\n  constructor(type) {\n    super(type);\n  }\n\n  getClassName() {\n    return PrimitiveValue.ClassName;\n  }\n\n}\n\nexports.PrimitiveValue = PrimitiveValue;\nPrimitiveValue.ClassName = \"PrimitiveValue\";\n\nfunction isTyped(value) {\n  return value.belongsToTypesystem !== undefined;\n}\n\nexports.isTyped = isTyped;\n\nclass TypePlaceholder extends Type {\n  constructor() {\n    super(\"...\");\n  }\n\n  getClassName() {\n    return TypePlaceholder.ClassName;\n  }\n\n}\n\nexports.TypePlaceholder = TypePlaceholder;\nTypePlaceholder.ClassName = \"TypePlaceholder\";\n\nclass NullType extends Type {\n  constructor() {\n    super(\"?\");\n  }\n\n  getClassName() {\n    return NullType.ClassName;\n  }\n\n}\n\nexports.NullType = NullType;\nNullType.ClassName = \"NullType\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\r\nconst reflection_1 = require(\"../../reflection\");\r\nconst utils_1 = require(\"../../utils\");\r\n/**\r\n * An abstraction that represents a Type. Handles both generic and non-generic types.\r\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\r\n */\r\nclass Type {\r\n    constructor(name, typeParameters = [], cardinality = TypeCardinality.fixed(1)) {\r\n        utils_1.guardValueIsSet(\"name\", name);\r\n        this.name = name;\r\n        this.typeParameters = typeParameters;\r\n        this.cardinality = cardinality;\r\n    }\r\n    getName() {\r\n        return this.name;\r\n    }\r\n    getClassName() {\r\n        return Type.ClassName;\r\n    }\r\n    getClassHierarchy() {\r\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\r\n        let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\r\n        return classNames;\r\n    }\r\n    /**\r\n     * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within erdjs' typesystem.\r\n     */\r\n    getFullyQualifiedName() {\r\n        let joinedTypeParameters = this.getTypeParameters().map(type => type.getFullyQualifiedName()).join(\", \");\r\n        return this.isGenericType() ?\r\n            `erdjs:types:${this.getName()}<${joinedTypeParameters}>` :\r\n            `erdjs:types:${this.getName()}`;\r\n    }\r\n    hasExactClass(className) {\r\n        return this.getClassName() == className;\r\n    }\r\n    hasClassOrSuperclass(className) {\r\n        let hierarchy = this.getClassHierarchy();\r\n        return hierarchy.includes(className);\r\n    }\r\n    getTypeParameters() {\r\n        return this.typeParameters;\r\n    }\r\n    isGenericType() {\r\n        return this.typeParameters.length > 0;\r\n    }\r\n    getFirstTypeParameter() {\r\n        utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\r\n        return this.typeParameters[0];\r\n    }\r\n    /**\r\n     * Generates type expressions similar to elrond-wasm-rs.\r\n     */\r\n    toString() {\r\n        let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\r\n        let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\r\n        return `${this.name}${typeParametersExpression}`;\r\n    }\r\n    equals(other) {\r\n        return Type.equals(this, other);\r\n    }\r\n    static equals(a, b) {\r\n        return a.getFullyQualifiedName() == b.getFullyQualifiedName();\r\n    }\r\n    static equalsMany(a, b) {\r\n        return a.every((type, i) => type.equals(b[i]));\r\n    }\r\n    static isAssignableFromMany(a, b) {\r\n        return a.every((type, i) => type.isAssignableFrom(b[i]));\r\n    }\r\n    differs(other) {\r\n        return !this.equals(other);\r\n    }\r\n    valueOf() {\r\n        return this.name;\r\n    }\r\n    /**\r\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\r\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\r\n     *\r\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\r\n     * For example, Option<u32> is assignable from Option<?>.\r\n     * For more details, see the implementation of {@link OptionType}.\r\n     *\r\n     * Also see:\r\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\r\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\r\n     */\r\n    isAssignableFrom(other) {\r\n        let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());\r\n        if (!invariantTypeParameters) {\r\n            return false;\r\n        }\r\n        let fullyQualifiedNameOfThis = this.getFullyQualifiedName();\r\n        let fullyQualifiedNamesInHierarchyOfOther = Type.getFullyQualifiedNamesInHierarchy(other);\r\n        if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {\r\n            return true;\r\n        }\r\n        return other.hasClassOrSuperclass(this.getClassName());\r\n    }\r\n    static getFullyQualifiedNamesInHierarchy(type) {\r\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, prototype => prototype.belongsToTypesystem);\r\n        let fullyQualifiedNames = prototypes.map(prototype => prototype.getFullyQualifiedName.call(type));\r\n        return fullyQualifiedNames;\r\n    }\r\n    /**\r\n     * Converts the account to a pretty, plain JavaScript object.\r\n     */\r\n    toJSON() {\r\n        return {\r\n            name: this.name,\r\n            typeParameters: this.typeParameters.map(item => item.toJSON())\r\n        };\r\n    }\r\n    getCardinality() {\r\n        return this.cardinality;\r\n    }\r\n    /**\r\n     * A special marker for types within erdjs' typesystem.\r\n     */\r\n    belongsToTypesystem() { }\r\n}\r\nexports.Type = Type;\r\nType.ClassName = \"Type\";\r\n/**\r\n * TODO: Simplify this class, keep only what is needed.\r\n *\r\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\r\n *\r\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\r\n * Composite types (not directly encodable) do not follow this constraint. For example:\r\n *  - VarArgs: [lower = 0, upper = *]\r\n *  - OptionalResult: [lower = 0, upper = 1]\r\n */\r\nclass TypeCardinality {\r\n    constructor(lowerBound, upperBound) {\r\n        this.lowerBound = lowerBound;\r\n        this.upperBound = upperBound;\r\n    }\r\n    static fixed(value) {\r\n        return new TypeCardinality(value, value);\r\n    }\r\n    static variable(value) {\r\n        return new TypeCardinality(0, value);\r\n    }\r\n    isSingular() {\r\n        return this.lowerBound == 1 && this.upperBound == 1;\r\n    }\r\n    isSingularOrNone() {\r\n        return this.lowerBound == 0 && this.upperBound == 1;\r\n    }\r\n    isComposite() {\r\n        return this.upperBound != 1;\r\n    }\r\n    isFixed() {\r\n        return this.lowerBound == this.upperBound;\r\n    }\r\n    getLowerBound() {\r\n        return this.lowerBound;\r\n    }\r\n    getUpperBound() {\r\n        return this.upperBound || TypeCardinality.MaxCardinality;\r\n    }\r\n}\r\nexports.TypeCardinality = TypeCardinality;\r\n/**\r\n * An arbitrarily chosen, reasonably large number.\r\n */\r\nTypeCardinality.MaxCardinality = 4096;\r\nclass PrimitiveType extends Type {\r\n    constructor(name) {\r\n        super(name);\r\n    }\r\n    getClassName() {\r\n        return PrimitiveType.ClassName;\r\n    }\r\n}\r\nexports.PrimitiveType = PrimitiveType;\r\nPrimitiveType.ClassName = \"PrimitiveType\";\r\nclass CustomType extends Type {\r\n    getClassName() {\r\n        return CustomType.ClassName;\r\n    }\r\n}\r\nexports.CustomType = CustomType;\r\nCustomType.ClassName = \"CustomType\";\r\nclass TypedValue {\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n    getClassName() {\r\n        return TypedValue.ClassName;\r\n    }\r\n    getClassHierarchy() {\r\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\r\n        let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\r\n        return classNames;\r\n    }\r\n    getType() {\r\n        return this.type;\r\n    }\r\n    hasExactClass(className) {\r\n        return this.getClassName() == className;\r\n    }\r\n    hasClassOrSuperclass(className) {\r\n        let hierarchy = this.getClassHierarchy();\r\n        return hierarchy.includes(className);\r\n    }\r\n    /**\r\n     * A special marker for values within erdjs' typesystem.\r\n     */\r\n    belongsToTypesystem() { }\r\n}\r\nexports.TypedValue = TypedValue;\r\nTypedValue.ClassName = \"TypedValue\";\r\nclass PrimitiveValue extends TypedValue {\r\n    constructor(type) {\r\n        super(type);\r\n    }\r\n    getClassName() {\r\n        return PrimitiveValue.ClassName;\r\n    }\r\n}\r\nexports.PrimitiveValue = PrimitiveValue;\r\nPrimitiveValue.ClassName = \"PrimitiveValue\";\r\nfunction isTyped(value) {\r\n    return value.belongsToTypesystem !== undefined;\r\n}\r\nexports.isTyped = isTyped;\r\nclass TypePlaceholder extends Type {\r\n    constructor() {\r\n        super(\"...\");\r\n    }\r\n    getClassName() {\r\n        return TypePlaceholder.ClassName;\r\n    }\r\n}\r\nexports.TypePlaceholder = TypePlaceholder;\r\nTypePlaceholder.ClassName = \"TypePlaceholder\";\r\nclass NullType extends Type {\r\n    constructor() {\r\n        super(\"?\");\r\n    }\r\n    getClassName() {\r\n        return NullType.ClassName;\r\n    }\r\n}\r\nexports.NullType = NullType;\r\nNullType.ClassName = \"NullType\";\r\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}