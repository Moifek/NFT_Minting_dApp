{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringBinaryCodec = void 0;\n\nconst typesystem_1 = require(\"../typesystem\");\n\nconst bytes_1 = require(\"../typesystem/bytes\");\n\nconst bytes_2 = require(\"./bytes\");\n\nclass StringBinaryCodec {\n  constructor() {\n    this.bytesBinaryCodec = new bytes_2.BytesBinaryCodec();\n  }\n\n  decodeNested(buffer) {\n    let [decoded, length] = this.bytesBinaryCodec.decodeNested(buffer);\n    let decodedAsString = new typesystem_1.StringValue(decoded.valueOf().toString());\n    return [decodedAsString, length];\n  }\n\n  decodeTopLevel(buffer) {\n    return new typesystem_1.StringValue(buffer.toString());\n  }\n\n  encodeNested(value) {\n    let valueAsBytes = bytes_1.BytesValue.fromUTF8(value.valueOf());\n    return this.bytesBinaryCodec.encodeNested(valueAsBytes);\n  }\n\n  encodeTopLevel(value) {\n    return Buffer.from(value.valueOf());\n  }\n\n}\n\nexports.StringBinaryCodec = StringBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/string.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAa,iBAAb,CAA8B;EAA9B,WAAA,GAAA;IACqB,KAAA,gBAAA,GAAmB,IAAI,OAAA,CAAA,gBAAJ,EAAnB;EAoBpB;;EAlBG,YAAY,CAAC,MAAD,EAAe;IACvB,IAAI,CAAC,OAAD,EAAU,MAAV,IAAoB,KAAK,gBAAL,CAAsB,YAAtB,CAAmC,MAAnC,CAAxB;IACA,IAAI,eAAe,GAAG,IAAI,YAAA,CAAA,WAAJ,CAAgB,OAAO,CAAC,OAAR,GAAkB,QAAlB,EAAhB,CAAtB;IACA,OAAO,CAAC,eAAD,EAAkB,MAAlB,CAAP;EACH;;EAED,cAAc,CAAC,MAAD,EAAe;IACzB,OAAO,IAAI,YAAA,CAAA,WAAJ,CAAgB,MAAM,CAAC,QAAP,EAAhB,CAAP;EACH;;EAED,YAAY,CAAC,KAAD,EAAmB;IAC3B,IAAI,YAAY,GAAG,OAAA,CAAA,UAAA,CAAW,QAAX,CAAoB,KAAK,CAAC,OAAN,EAApB,CAAnB;IACA,OAAO,KAAK,gBAAL,CAAsB,YAAtB,CAAmC,YAAnC,CAAP;EACH;;EAED,cAAc,CAAC,KAAD,EAAmB;IAC7B,OAAO,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,OAAN,EAAZ,CAAP;EACH;;AApByB;;AAA9B,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StringBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst bytes_1 = require(\"../typesystem/bytes\");\nconst bytes_2 = require(\"./bytes\");\nclass StringBinaryCodec {\n    constructor() {\n        this.bytesBinaryCodec = new bytes_2.BytesBinaryCodec();\n    }\n    decodeNested(buffer) {\n        let [decoded, length] = this.bytesBinaryCodec.decodeNested(buffer);\n        let decodedAsString = new typesystem_1.StringValue(decoded.valueOf().toString());\n        return [decodedAsString, length];\n    }\n    decodeTopLevel(buffer) {\n        return new typesystem_1.StringValue(buffer.toString());\n    }\n    encodeNested(value) {\n        let valueAsBytes = bytes_1.BytesValue.fromUTF8(value.valueOf());\n        return this.bytesBinaryCodec.encodeNested(valueAsBytes);\n    }\n    encodeTopLevel(value) {\n        return Buffer.from(value.valueOf());\n    }\n}\nexports.StringBinaryCodec = StringBinaryCodec;\n//# sourceMappingURL=string.js.map"]},"metadata":{},"sourceType":"script"}